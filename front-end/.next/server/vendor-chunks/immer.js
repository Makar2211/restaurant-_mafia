"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/immer";
exports.ids = ["vendor-chunks/immer"];
exports.modules = {

/***/ "(ssr)/./node_modules/immer/dist/immer.cjs.development.js":
/*!**********************************************************!*\
  !*** ./node_modules/immer/dist/immer.cjs.development.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\r\nvar _ref;\r\n\r\n// Should be no imports here!\r\n// Some things that should be evaluated before all else...\r\n// We only want to know if non-polyfilled symbols are available\r\nvar hasSymbol = typeof Symbol !== \"undefined\" && typeof\r\n/*#__PURE__*/\r\nSymbol(\"x\") === \"symbol\";\r\nvar hasMap = typeof Map !== \"undefined\";\r\nvar hasSet = typeof Set !== \"undefined\";\r\nvar hasProxies = typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\";\r\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */\r\n\r\nvar NOTHING = hasSymbol ?\r\n/*#__PURE__*/\r\nSymbol.for(\"immer-nothing\") : (_ref = {}, _ref[\"immer-nothing\"] = true, _ref);\r\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */\r\n\r\nvar DRAFTABLE = hasSymbol ?\r\n/*#__PURE__*/\r\nSymbol.for(\"immer-draftable\") : \"__$immer_draftable\";\r\nvar DRAFT_STATE = hasSymbol ?\r\n/*#__PURE__*/\r\nSymbol.for(\"immer-state\") : \"__$immer_state\"; // Even a polyfilled Symbol might provide Symbol.iterator\r\n\r\nvar iteratorSymbol = typeof Symbol != \"undefined\" && Symbol.iterator || \"@@iterator\";\r\n\r\nvar errors = {\r\n  0: \"Illegal state\",\r\n  1: \"Immer drafts cannot have computed properties\",\r\n  2: \"This object has been frozen and should not be mutated\",\r\n  3: function _(data) {\r\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\r\n  },\r\n  4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\r\n  5: \"Immer forbids circular references\",\r\n  6: \"The first or second argument to `produce` must be a function\",\r\n  7: \"The third argument to `produce` must be a function or undefined\",\r\n  8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\r\n  9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\r\n  10: \"The given draft is already finalized\",\r\n  11: \"Object.defineProperty() cannot be used on an Immer draft\",\r\n  12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\r\n  13: \"Immer only supports deleting array indices\",\r\n  14: \"Immer only supports setting array indices and the 'length' property\",\r\n  15: function _(path) {\r\n    return \"Cannot apply patch, path doesn't resolve: \" + path;\r\n  },\r\n  16: 'Sets cannot have \"replace\" patches.',\r\n  17: function _(op) {\r\n    return \"Unsupported patch operation: \" + op;\r\n  },\r\n  18: function _(plugin) {\r\n    return \"The plugin for '\" + plugin + \"' has not been loaded into Immer. To enable the plugin, import and call `enable\" + plugin + \"()` when initializing your application.\";\r\n  },\r\n  20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\r\n  21: function _(thing) {\r\n    return \"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\" + thing + \"'\";\r\n  },\r\n  22: function _(thing) {\r\n    return \"'current' expects a draft, got: \" + thing;\r\n  },\r\n  23: function _(thing) {\r\n    return \"'original' expects a draft, got: \" + thing;\r\n  },\r\n  24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\r\n};\r\nfunction die(error) {\r\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n    args[_key - 1] = arguments[_key];\r\n  }\r\n\r\n  {\r\n    var e = errors[error];\r\n    var msg = !e ? \"unknown error nr: \" + error : typeof e === \"function\" ? e.apply(null, args) : e;\r\n    throw new Error(\"[Immer] \" + msg);\r\n  }\r\n}\r\n\r\n/** Returns true if the given value is an Immer draft */\r\n\r\n/*#__PURE__*/\r\n\r\nfunction isDraft(value) {\r\n  return !!value && !!value[DRAFT_STATE];\r\n}\r\n/** Returns true if the given value can be drafted by Immer */\r\n\r\n/*#__PURE__*/\r\n\r\nfunction isDraftable(value) {\r\n  var _value$constructor;\r\n\r\n  if (!value) return false;\r\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor[DRAFTABLE]) || isMap(value) || isSet(value);\r\n}\r\nvar objectCtorString =\r\n/*#__PURE__*/\r\nObject.prototype.constructor.toString();\r\n/*#__PURE__*/\r\n\r\nfunction isPlainObject(value) {\r\n  if (!value || typeof value !== \"object\") return false;\r\n  var proto = Object.getPrototypeOf(value);\r\n\r\n  if (proto === null) {\r\n    return true;\r\n  }\r\n\r\n  var Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\r\n  if (Ctor === Object) return true;\r\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\r\n}\r\nfunction original(value) {\r\n  if (!isDraft(value)) die(23, value);\r\n  return value[DRAFT_STATE].base_;\r\n}\r\n/*#__PURE__*/\r\n\r\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\r\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\r\n} :\r\n/* istanbul ignore next */\r\nObject.getOwnPropertyNames;\r\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {\r\n  // Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\r\n  var res = {};\r\n  ownKeys(target).forEach(function (key) {\r\n    res[key] = Object.getOwnPropertyDescriptor(target, key);\r\n  });\r\n  return res;\r\n};\r\nfunction each(obj, iter, enumerableOnly) {\r\n  if (enumerableOnly === void 0) {\r\n    enumerableOnly = false;\r\n  }\r\n\r\n  if (getArchtype(obj) === 0\r\n  /* Object */\r\n  ) {\r\n      (enumerableOnly ? Object.keys : ownKeys)(obj).forEach(function (key) {\r\n        if (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj);\r\n      });\r\n    } else {\r\n    obj.forEach(function (entry, index) {\r\n      return iter(index, entry, obj);\r\n    });\r\n  }\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction getArchtype(thing) {\r\n  /* istanbul ignore next */\r\n  var state = thing[DRAFT_STATE];\r\n  return state ? state.type_ > 3 ? state.type_ - 4 // cause Object and Array map back from 4 and 5\r\n  : state.type_ // others are the same\r\n  : Array.isArray(thing) ? 1\r\n  /* Array */\r\n  : isMap(thing) ? 2\r\n  /* Map */\r\n  : isSet(thing) ? 3\r\n  /* Set */\r\n  : 0\r\n  /* Object */\r\n  ;\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction has(thing, prop) {\r\n  return getArchtype(thing) === 2\r\n  /* Map */\r\n  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction get(thing, prop) {\r\n  // @ts-ignore\r\n  return getArchtype(thing) === 2\r\n  /* Map */\r\n  ? thing.get(prop) : thing[prop];\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction set(thing, propOrOldValue, value) {\r\n  var t = getArchtype(thing);\r\n  if (t === 2\r\n  /* Map */\r\n  ) thing.set(propOrOldValue, value);else if (t === 3\r\n  /* Set */\r\n  ) {\r\n      thing.add(value);\r\n    } else thing[propOrOldValue] = value;\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction is(x, y) {\r\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\r\n  if (x === y) {\r\n    return x !== 0 || 1 / x === 1 / y;\r\n  } else {\r\n    return x !== x && y !== y;\r\n  }\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction isMap(target) {\r\n  return hasMap && target instanceof Map;\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction isSet(target) {\r\n  return hasSet && target instanceof Set;\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction latest(state) {\r\n  return state.copy_ || state.base_;\r\n}\r\n/*#__PURE__*/\r\n\r\nfunction shallowCopy(base) {\r\n  if (Array.isArray(base)) return Array.prototype.slice.call(base);\r\n  var descriptors = getOwnPropertyDescriptors(base);\r\n  delete descriptors[DRAFT_STATE];\r\n  var keys = ownKeys(descriptors);\r\n\r\n  for (var i = 0; i < keys.length; i++) {\r\n    var key = keys[i];\r\n    var desc = descriptors[key];\r\n\r\n    if (desc.writable === false) {\r\n      desc.writable = true;\r\n      desc.configurable = true;\r\n    } // like object.assign, we will read any _own_, get/set accessors. This helps in dealing\r\n    // with libraries that trap values, like mobx or vue\r\n    // unlike object.assign, non-enumerables will be copied as well\r\n\r\n\r\n    if (desc.get || desc.set) descriptors[key] = {\r\n      configurable: true,\r\n      writable: true,\r\n      enumerable: desc.enumerable,\r\n      value: base[key]\r\n    };\r\n  }\r\n\r\n  return Object.create(Object.getPrototypeOf(base), descriptors);\r\n}\r\nfunction freeze(obj, deep) {\r\n  if (deep === void 0) {\r\n    deep = false;\r\n  }\r\n\r\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;\r\n\r\n  if (getArchtype(obj) > 1\r\n  /* Map or Set */\r\n  ) {\r\n      obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\r\n    }\r\n\r\n  Object.freeze(obj);\r\n  if (deep) each(obj, function (key, value) {\r\n    return freeze(value, true);\r\n  }, true);\r\n  return obj;\r\n}\r\n\r\nfunction dontMutateFrozenCollections() {\r\n  die(2);\r\n}\r\n\r\nfunction isFrozen(obj) {\r\n  if (obj == null || typeof obj !== \"object\") return true; // See #600, IE dies on non-objects in Object.isFrozen\r\n\r\n  return Object.isFrozen(obj);\r\n}\r\n\r\n/** Plugin utilities */\r\n\r\nvar plugins = {};\r\nfunction getPlugin(pluginKey) {\r\n  var plugin = plugins[pluginKey];\r\n\r\n  if (!plugin) {\r\n    die(18, pluginKey);\r\n  } // @ts-ignore\r\n\r\n\r\n  return plugin;\r\n}\r\nfunction loadPlugin(pluginKey, implementation) {\r\n  if (!plugins[pluginKey]) plugins[pluginKey] = implementation;\r\n}\r\n\r\nvar currentScope;\r\nfunction getCurrentScope() {\r\n  if ( !currentScope) die(0);\r\n  return currentScope;\r\n}\r\n\r\nfunction createScope(parent_, immer_) {\r\n  return {\r\n    drafts_: [],\r\n    parent_: parent_,\r\n    immer_: immer_,\r\n    // Whenever the modified draft contains a draft from another scope, we\r\n    // need to prevent auto-freezing so the unowned draft can be finalized.\r\n    canAutoFreeze_: true,\r\n    unfinalizedDrafts_: 0\r\n  };\r\n}\r\n\r\nfunction usePatchesInScope(scope, patchListener) {\r\n  if (patchListener) {\r\n    getPlugin(\"Patches\"); // assert we have the plugin\r\n\r\n    scope.patches_ = [];\r\n    scope.inversePatches_ = [];\r\n    scope.patchListener_ = patchListener;\r\n  }\r\n}\r\nfunction revokeScope(scope) {\r\n  leaveScope(scope);\r\n  scope.drafts_.forEach(revokeDraft); // @ts-ignore\r\n\r\n  scope.drafts_ = null;\r\n}\r\nfunction leaveScope(scope) {\r\n  if (scope === currentScope) {\r\n    currentScope = scope.parent_;\r\n  }\r\n}\r\nfunction enterScope(immer) {\r\n  return currentScope = createScope(currentScope, immer);\r\n}\r\n\r\nfunction revokeDraft(draft) {\r\n  var state = draft[DRAFT_STATE];\r\n  if (state.type_ === 0\r\n  /* ProxyObject */\r\n  || state.type_ === 1\r\n  /* ProxyArray */\r\n  ) state.revoke_();else state.revoked_ = true;\r\n}\r\n\r\nfunction processResult(result, scope) {\r\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\r\n  var baseDraft = scope.drafts_[0];\r\n  var isReplaced = result !== undefined && result !== baseDraft;\r\n  if (!scope.immer_.useProxies_) getPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced);\r\n\r\n  if (isReplaced) {\r\n    if (baseDraft[DRAFT_STATE].modified_) {\r\n      revokeScope(scope);\r\n      die(4);\r\n    }\r\n\r\n    if (isDraftable(result)) {\r\n      // Finalize the result in case it contains (or is) a subset of the draft.\r\n      result = finalize(scope, result);\r\n      if (!scope.parent_) maybeFreeze(scope, result);\r\n    }\r\n\r\n    if (scope.patches_) {\r\n      getPlugin(\"Patches\").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);\r\n    }\r\n  } else {\r\n    // Finalize the base draft.\r\n    result = finalize(scope, baseDraft, []);\r\n  }\r\n\r\n  revokeScope(scope);\r\n\r\n  if (scope.patches_) {\r\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\r\n  }\r\n\r\n  return result !== NOTHING ? result : undefined;\r\n}\r\n\r\nfunction finalize(rootScope, value, path) {\r\n  // Don't recurse in tho recursive data structures\r\n  if (isFrozen(value)) return value;\r\n  var state = value[DRAFT_STATE]; // A plain object, might need freezing, might contain drafts\r\n\r\n  if (!state) {\r\n    each(value, function (key, childValue) {\r\n      return finalizeProperty(rootScope, state, value, key, childValue, path);\r\n    }, true // See #590, don't recurse into non-enumerable of non drafted objects\r\n    );\r\n    return value;\r\n  } // Never finalize drafts owned by another scope.\r\n\r\n\r\n  if (state.scope_ !== rootScope) return value; // Unmodified draft, return the (frozen) original\r\n\r\n  if (!state.modified_) {\r\n    maybeFreeze(rootScope, state.base_, true);\r\n    return state.base_;\r\n  } // Not finalized yet, let's do that now\r\n\r\n\r\n  if (!state.finalized_) {\r\n    state.finalized_ = true;\r\n    state.scope_.unfinalizedDrafts_--;\r\n    var result = // For ES5, create a good copy from the draft first, with added keys and without deleted keys.\r\n    state.type_ === 4\r\n    /* ES5Object */\r\n    || state.type_ === 5\r\n    /* ES5Array */\r\n    ? state.copy_ = shallowCopy(state.draft_) : state.copy_; // Finalize all children of the copy\r\n    // For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\r\n    // To preserve insertion order in all cases we then clear the set\r\n    // And we let finalizeProperty know it needs to re-add non-draft children back to the target\r\n\r\n    var resultEach = result;\r\n    var isSet = false;\r\n\r\n    if (state.type_ === 3\r\n    /* Set */\r\n    ) {\r\n        resultEach = new Set(result);\r\n        result.clear();\r\n        isSet = true;\r\n      }\r\n\r\n    each(resultEach, function (key, childValue) {\r\n      return finalizeProperty(rootScope, state, result, key, childValue, path, isSet);\r\n    }); // everything inside is frozen, we can freeze here\r\n\r\n    maybeFreeze(rootScope, result, false); // first time finalizing, let's create those patches\r\n\r\n    if (path && rootScope.patches_) {\r\n      getPlugin(\"Patches\").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);\r\n    }\r\n  }\r\n\r\n  return state.copy_;\r\n}\r\n\r\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\r\n  if ( childValue === targetObject) die(5);\r\n\r\n  if (isDraft(childValue)) {\r\n    var path = rootPath && parentState && parentState.type_ !== 3\r\n    /* Set */\r\n    && // Set objects are atomic since they have no keys.\r\n    !has(parentState.assigned_, prop) // Skip deep patches for assigned keys.\r\n    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\r\n\r\n    var res = finalize(rootScope, childValue, path);\r\n    set(targetObject, prop, res); // Drafts from another scope must prevented to be frozen\r\n    // if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\r\n\r\n    if (isDraft(res)) {\r\n      rootScope.canAutoFreeze_ = false;\r\n    } else return;\r\n  } else if (targetIsSet) {\r\n    targetObject.add(childValue);\r\n  } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\r\n\r\n\r\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\r\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\r\n      // optimization: if an object is not a draft, and we don't have to\r\n      // deepfreeze everything, and we are sure that no drafts are left in the remaining object\r\n      // cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\r\n      // This benefits especially adding large data tree's without further processing.\r\n      // See add-data.js perf test\r\n      return;\r\n    }\r\n\r\n    finalize(rootScope, childValue); // immer deep freezes plain objects, so if there is no parent state, we freeze as well\r\n\r\n    if (!parentState || !parentState.scope_.parent_) maybeFreeze(rootScope, childValue);\r\n  }\r\n}\r\n\r\nfunction maybeFreeze(scope, value, deep) {\r\n  if (deep === void 0) {\r\n    deep = false;\r\n  }\r\n\r\n  // we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\r\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\r\n    freeze(value, deep);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\r\n\r\nfunction createProxyProxy(base, parent) {\r\n  var isArray = Array.isArray(base);\r\n  var state = {\r\n    type_: isArray ? 1\r\n    /* ProxyArray */\r\n    : 0\r\n    /* ProxyObject */\r\n    ,\r\n    // Track which produce call this is associated with.\r\n    scope_: parent ? parent.scope_ : getCurrentScope(),\r\n    // True for both shallow and deep changes.\r\n    modified_: false,\r\n    // Used during finalization.\r\n    finalized_: false,\r\n    // Track which properties have been assigned (true) or deleted (false).\r\n    assigned_: {},\r\n    // The parent draft state.\r\n    parent_: parent,\r\n    // The base state.\r\n    base_: base,\r\n    // The base proxy.\r\n    draft_: null,\r\n    // The base copy with any updated values.\r\n    copy_: null,\r\n    // Called by the `produce` function.\r\n    revoke_: null,\r\n    isManual_: false\r\n  }; // the traps must target something, a bit like the 'real' base.\r\n  // but also, we need to be able to determine from the target what the relevant state is\r\n  // (to avoid creating traps per instance to capture the state in closure,\r\n  // and to avoid creating weird hidden properties as well)\r\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\r\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\r\n\r\n  var target = state;\r\n  var traps = objectTraps;\r\n\r\n  if (isArray) {\r\n    target = [state];\r\n    traps = arrayTraps;\r\n  }\r\n\r\n  var _Proxy$revocable = Proxy.revocable(target, traps),\r\n      revoke = _Proxy$revocable.revoke,\r\n      proxy = _Proxy$revocable.proxy;\r\n\r\n  state.draft_ = proxy;\r\n  state.revoke_ = revoke;\r\n  return proxy;\r\n}\r\n/**\r\n * Object drafts\r\n */\r\n\r\nvar objectTraps = {\r\n  get: function get(state, prop) {\r\n    if (prop === DRAFT_STATE) return state;\r\n    var source = latest(state);\r\n\r\n    if (!has(source, prop)) {\r\n      // non-existing or non-own property...\r\n      return readPropFromProto(state, source, prop);\r\n    }\r\n\r\n    var value = source[prop];\r\n\r\n    if (state.finalized_ || !isDraftable(value)) {\r\n      return value;\r\n    } // Check for existing draft in modified state.\r\n    // Assigned values are never drafted. This catches any drafts we created, too.\r\n\r\n\r\n    if (value === peek(state.base_, prop)) {\r\n      prepareCopy(state);\r\n      return state.copy_[prop] = createProxy(state.scope_.immer_, value, state);\r\n    }\r\n\r\n    return value;\r\n  },\r\n  has: function has(state, prop) {\r\n    return prop in latest(state);\r\n  },\r\n  ownKeys: function ownKeys(state) {\r\n    return Reflect.ownKeys(latest(state));\r\n  },\r\n  set: function set(state, prop\r\n  /* strictly not, but helps TS */\r\n  , value) {\r\n    var desc = getDescriptorFromProto(latest(state), prop);\r\n\r\n    if (desc === null || desc === void 0 ? void 0 : desc.set) {\r\n      // special case: if this write is captured by a setter, we have\r\n      // to trigger it with the correct context\r\n      desc.set.call(state.draft_, value);\r\n      return true;\r\n    }\r\n\r\n    if (!state.modified_) {\r\n      // the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\r\n      // from setting an existing property with value undefined to undefined (which is not a change)\r\n      var current = peek(latest(state), prop); // special case, if we assigning the original value to a draft, we can ignore the assignment\r\n\r\n      var currentState = current === null || current === void 0 ? void 0 : current[DRAFT_STATE];\r\n\r\n      if (currentState && currentState.base_ === value) {\r\n        state.copy_[prop] = value;\r\n        state.assigned_[prop] = false;\r\n        return true;\r\n      }\r\n\r\n      if (is(value, current) && (value !== undefined || has(state.base_, prop))) return true;\r\n      prepareCopy(state);\r\n      markChanged(state);\r\n    }\r\n\r\n    if (state.copy_[prop] === value && ( // special case: handle new props with value 'undefined'\r\n    value !== undefined || prop in state.copy_) || // special case: NaN\r\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true; // @ts-ignore\r\n\r\n    state.copy_[prop] = value;\r\n    state.assigned_[prop] = true;\r\n    return true;\r\n  },\r\n  deleteProperty: function deleteProperty(state, prop) {\r\n    // The `undefined` check is a fast path for pre-existing keys.\r\n    if (peek(state.base_, prop) !== undefined || prop in state.base_) {\r\n      state.assigned_[prop] = false;\r\n      prepareCopy(state);\r\n      markChanged(state);\r\n    } else {\r\n      // if an originally not assigned property was deleted\r\n      delete state.assigned_[prop];\r\n    } // @ts-ignore\r\n\r\n\r\n    if (state.copy_) delete state.copy_[prop];\r\n    return true;\r\n  },\r\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\r\n  // the same guarantee in ES5 mode.\r\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {\r\n    var owner = latest(state);\r\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\r\n    if (!desc) return desc;\r\n    return {\r\n      writable: true,\r\n      configurable: state.type_ !== 1\r\n      /* ProxyArray */\r\n      || prop !== \"length\",\r\n      enumerable: desc.enumerable,\r\n      value: owner[prop]\r\n    };\r\n  },\r\n  defineProperty: function defineProperty() {\r\n    die(11);\r\n  },\r\n  getPrototypeOf: function getPrototypeOf(state) {\r\n    return Object.getPrototypeOf(state.base_);\r\n  },\r\n  setPrototypeOf: function setPrototypeOf() {\r\n    die(12);\r\n  }\r\n};\r\n/**\r\n * Array drafts\r\n */\r\n\r\nvar arrayTraps = {};\r\neach(objectTraps, function (key, fn) {\r\n  // @ts-ignore\r\n  arrayTraps[key] = function () {\r\n    arguments[0] = arguments[0][0];\r\n    return fn.apply(this, arguments);\r\n  };\r\n});\r\n\r\narrayTraps.deleteProperty = function (state, prop) {\r\n  if ( isNaN(parseInt(prop))) die(13); // @ts-ignore\r\n\r\n  return arrayTraps.set.call(this, state, prop, undefined);\r\n};\r\n\r\narrayTraps.set = function (state, prop, value) {\r\n  if ( prop !== \"length\" && isNaN(parseInt(prop))) die(14);\r\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\r\n}; // Access a property without creating an Immer draft.\r\n\r\n\r\nfunction peek(draft, prop) {\r\n  var state = draft[DRAFT_STATE];\r\n  var source = state ? latest(state) : draft;\r\n  return source[prop];\r\n}\r\n\r\nfunction readPropFromProto(state, source, prop) {\r\n  var _desc$get;\r\n\r\n  var desc = getDescriptorFromProto(source, prop);\r\n  return desc ? \"value\" in desc ? desc.value : // This is a very special case, if the prop is a getter defined by the\r\n  // prototype, we should invoke it with the draft as context!\r\n  (_desc$get = desc.get) === null || _desc$get === void 0 ? void 0 : _desc$get.call(state.draft_) : undefined;\r\n}\r\n\r\nfunction getDescriptorFromProto(source, prop) {\r\n  // 'in' checks proto!\r\n  if (!(prop in source)) return undefined;\r\n  var proto = Object.getPrototypeOf(source);\r\n\r\n  while (proto) {\r\n    var desc = Object.getOwnPropertyDescriptor(proto, prop);\r\n    if (desc) return desc;\r\n    proto = Object.getPrototypeOf(proto);\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction markChanged(state) {\r\n  if (!state.modified_) {\r\n    state.modified_ = true;\r\n\r\n    if (state.parent_) {\r\n      markChanged(state.parent_);\r\n    }\r\n  }\r\n}\r\nfunction prepareCopy(state) {\r\n  if (!state.copy_) {\r\n    state.copy_ = shallowCopy(state.base_);\r\n  }\r\n}\r\n\r\nvar Immer =\r\n/*#__PURE__*/\r\nfunction () {\r\n  function Immer(config) {\r\n    var _this = this;\r\n\r\n    this.useProxies_ = hasProxies;\r\n    this.autoFreeze_ = true;\r\n    /**\r\n     * The `produce` function takes a value and a \"recipe function\" (whose\r\n     * return value often depends on the base state). The recipe function is\r\n     * free to mutate its first argument however it wants. All mutations are\r\n     * only ever applied to a __copy__ of the base state.\r\n     *\r\n     * Pass only a function to create a \"curried producer\" which relieves you\r\n     * from passing the recipe function every time.\r\n     *\r\n     * Only plain objects and arrays are made mutable. All other objects are\r\n     * considered uncopyable.\r\n     *\r\n     * Note: This function is __bound__ to its `Immer` instance.\r\n     *\r\n     * @param {any} base - the initial state\r\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\r\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n     * @returns {any} a new state, or the initial state if nothing was modified\r\n     */\r\n\r\n    this.produce = function (base, recipe, patchListener) {\r\n      // curried invocation\r\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\r\n        var defaultBase = recipe;\r\n        recipe = base;\r\n        var self = _this;\r\n        return function curriedProduce(base) {\r\n          var _this2 = this;\r\n\r\n          if (base === void 0) {\r\n            base = defaultBase;\r\n          }\r\n\r\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n            args[_key - 1] = arguments[_key];\r\n          }\r\n\r\n          return self.produce(base, function (draft) {\r\n            var _recipe;\r\n\r\n            return (_recipe = recipe).call.apply(_recipe, [_this2, draft].concat(args));\r\n          }); // prettier-ignore\r\n        };\r\n      }\r\n\r\n      if (typeof recipe !== \"function\") die(6);\r\n      if (patchListener !== undefined && typeof patchListener !== \"function\") die(7);\r\n      var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\r\n\r\n      if (isDraftable(base)) {\r\n        var scope = enterScope(_this);\r\n        var proxy = createProxy(_this, base, undefined);\r\n        var hasError = true;\r\n\r\n        try {\r\n          result = recipe(proxy);\r\n          hasError = false;\r\n        } finally {\r\n          // finally instead of catch + rethrow better preserves original stack\r\n          if (hasError) revokeScope(scope);else leaveScope(scope);\r\n        }\r\n\r\n        if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n          return result.then(function (result) {\r\n            usePatchesInScope(scope, patchListener);\r\n            return processResult(result, scope);\r\n          }, function (error) {\r\n            revokeScope(scope);\r\n            throw error;\r\n          });\r\n        }\r\n\r\n        usePatchesInScope(scope, patchListener);\r\n        return processResult(result, scope);\r\n      } else if (!base || typeof base !== \"object\") {\r\n        result = recipe(base);\r\n        if (result === undefined) result = base;\r\n        if (result === NOTHING) result = undefined;\r\n        if (_this.autoFreeze_) freeze(result, true);\r\n\r\n        if (patchListener) {\r\n          var p = [];\r\n          var ip = [];\r\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\r\n          patchListener(p, ip);\r\n        }\r\n\r\n        return result;\r\n      } else die(21, base);\r\n    };\r\n\r\n    this.produceWithPatches = function (base, recipe) {\r\n      // curried invocation\r\n      if (typeof base === \"function\") {\r\n        return function (state) {\r\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\r\n            args[_key2 - 1] = arguments[_key2];\r\n          }\r\n\r\n          return _this.produceWithPatches(state, function (draft) {\r\n            return base.apply(void 0, [draft].concat(args));\r\n          });\r\n        };\r\n      }\r\n\r\n      var patches, inversePatches;\r\n\r\n      var result = _this.produce(base, recipe, function (p, ip) {\r\n        patches = p;\r\n        inversePatches = ip;\r\n      });\r\n\r\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\r\n        return result.then(function (nextState) {\r\n          return [nextState, patches, inversePatches];\r\n        });\r\n      }\r\n\r\n      return [result, patches, inversePatches];\r\n    };\r\n\r\n    if (typeof (config === null || config === void 0 ? void 0 : config.useProxies) === \"boolean\") this.setUseProxies(config.useProxies);\r\n    if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === \"boolean\") this.setAutoFreeze(config.autoFreeze);\r\n  }\r\n\r\n  var _proto = Immer.prototype;\r\n\r\n  _proto.createDraft = function createDraft(base) {\r\n    if (!isDraftable(base)) die(8);\r\n    if (isDraft(base)) base = current(base);\r\n    var scope = enterScope(this);\r\n    var proxy = createProxy(this, base, undefined);\r\n    proxy[DRAFT_STATE].isManual_ = true;\r\n    leaveScope(scope);\r\n    return proxy;\r\n  };\r\n\r\n  _proto.finishDraft = function finishDraft(draft, patchListener) {\r\n    var state = draft && draft[DRAFT_STATE];\r\n\r\n    {\r\n      if (!state || !state.isManual_) die(9);\r\n      if (state.finalized_) die(10);\r\n    }\r\n\r\n    var scope = state.scope_;\r\n    usePatchesInScope(scope, patchListener);\r\n    return processResult(undefined, scope);\r\n  }\r\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is enabled.\r\n   */\r\n  ;\r\n\r\n  _proto.setAutoFreeze = function setAutoFreeze(value) {\r\n    this.autoFreeze_ = value;\r\n  }\r\n  /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */\r\n  ;\r\n\r\n  _proto.setUseProxies = function setUseProxies(value) {\r\n    if (value && !hasProxies) {\r\n      die(20);\r\n    }\r\n\r\n    this.useProxies_ = value;\r\n  };\r\n\r\n  _proto.applyPatches = function applyPatches(base, patches) {\r\n    // If a patch replaces the entire state, take that replacement as base\r\n    // before applying patches\r\n    var i;\r\n\r\n    for (i = patches.length - 1; i >= 0; i--) {\r\n      var patch = patches[i];\r\n\r\n      if (patch.path.length === 0 && patch.op === \"replace\") {\r\n        base = patch.value;\r\n        break;\r\n      }\r\n    } // If there was a patch that replaced the entire state, start from the\r\n    // patch after that.\r\n\r\n\r\n    if (i > -1) {\r\n      patches = patches.slice(i + 1);\r\n    }\r\n\r\n    var applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\r\n\r\n    if (isDraft(base)) {\r\n      // N.B: never hits if some patch a replacement, patches are never drafts\r\n      return applyPatchesImpl(base, patches);\r\n    } // Otherwise, produce a copy of the base state.\r\n\r\n\r\n    return this.produce(base, function (draft) {\r\n      return applyPatchesImpl(draft, patches);\r\n    });\r\n  };\r\n\r\n  return Immer;\r\n}();\r\nfunction createProxy(immer, value, parent) {\r\n  // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\r\n  var draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : immer.useProxies_ ? createProxyProxy(value, parent) : getPlugin(\"ES5\").createES5Proxy_(value, parent);\r\n  var scope = parent ? parent.scope_ : getCurrentScope();\r\n  scope.drafts_.push(draft);\r\n  return draft;\r\n}\r\n\r\nfunction current(value) {\r\n  if (!isDraft(value)) die(22, value);\r\n  return currentImpl(value);\r\n}\r\n\r\nfunction currentImpl(value) {\r\n  if (!isDraftable(value)) return value;\r\n  var state = value[DRAFT_STATE];\r\n  var copy;\r\n  var archType = getArchtype(value);\r\n\r\n  if (state) {\r\n    if (!state.modified_ && (state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state))) return state.base_; // Optimization: avoid generating new drafts during copying\r\n\r\n    state.finalized_ = true;\r\n    copy = copyHelper(value, archType);\r\n    state.finalized_ = false;\r\n  } else {\r\n    copy = copyHelper(value, archType);\r\n  }\r\n\r\n  each(copy, function (key, childValue) {\r\n    if (state && get(state.base_, key) === childValue) return; // no need to copy or search in something that didn't change\r\n\r\n    set(copy, key, currentImpl(childValue));\r\n  }); // In the future, we might consider freezing here, based on the current settings\r\n\r\n  return archType === 3\r\n  /* Set */\r\n  ? new Set(copy) : copy;\r\n}\r\n\r\nfunction copyHelper(value, archType) {\r\n  // creates a shallow copy, even if it is a map or set\r\n  switch (archType) {\r\n    case 2\r\n    /* Map */\r\n    :\r\n      return new Map(value);\r\n\r\n    case 3\r\n    /* Set */\r\n    :\r\n      // Set will be cloned as array temporarily, so that we can replace individual items\r\n      return Array.from(value);\r\n  }\r\n\r\n  return shallowCopy(value);\r\n}\r\n\r\nfunction enableES5() {\r\n  function willFinalizeES5_(scope, result, isReplaced) {\r\n    if (!isReplaced) {\r\n      if (scope.patches_) {\r\n        markChangesRecursively(scope.drafts_[0]);\r\n      } // This is faster when we don't care about which attributes changed.\r\n\r\n\r\n      markChangesSweep(scope.drafts_);\r\n    } // When a child draft is returned, look for changes.\r\n    else if (isDraft(result) && result[DRAFT_STATE].scope_ === scope) {\r\n        markChangesSweep(scope.drafts_);\r\n      }\r\n  }\r\n\r\n  function createES5Draft(isArray, base) {\r\n    if (isArray) {\r\n      var draft = new Array(base.length);\r\n\r\n      for (var i = 0; i < base.length; i++) {\r\n        Object.defineProperty(draft, \"\" + i, proxyProperty(i, true));\r\n      }\r\n\r\n      return draft;\r\n    } else {\r\n      var _descriptors = getOwnPropertyDescriptors(base);\r\n\r\n      delete _descriptors[DRAFT_STATE];\r\n      var keys = ownKeys(_descriptors);\r\n\r\n      for (var _i = 0; _i < keys.length; _i++) {\r\n        var key = keys[_i];\r\n        _descriptors[key] = proxyProperty(key, isArray || !!_descriptors[key].enumerable);\r\n      }\r\n\r\n      return Object.create(Object.getPrototypeOf(base), _descriptors);\r\n    }\r\n  }\r\n\r\n  function createES5Proxy_(base, parent) {\r\n    var isArray = Array.isArray(base);\r\n    var draft = createES5Draft(isArray, base);\r\n    var state = {\r\n      type_: isArray ? 5\r\n      /* ES5Array */\r\n      : 4\r\n      /* ES5Object */\r\n      ,\r\n      scope_: parent ? parent.scope_ : getCurrentScope(),\r\n      modified_: false,\r\n      finalized_: false,\r\n      assigned_: {},\r\n      parent_: parent,\r\n      // base is the object we are drafting\r\n      base_: base,\r\n      // draft is the draft object itself, that traps all reads and reads from either the base (if unmodified) or copy (if modified)\r\n      draft_: draft,\r\n      copy_: null,\r\n      revoked_: false,\r\n      isManual_: false\r\n    };\r\n    Object.defineProperty(draft, DRAFT_STATE, {\r\n      value: state,\r\n      // enumerable: false <- the default\r\n      writable: true\r\n    });\r\n    return draft;\r\n  } // property descriptors are recycled to make sure we don't create a get and set closure per property,\r\n  // but share them all instead\r\n\r\n\r\n  var descriptors = {};\r\n\r\n  function proxyProperty(prop, enumerable) {\r\n    var desc = descriptors[prop];\r\n\r\n    if (desc) {\r\n      desc.enumerable = enumerable;\r\n    } else {\r\n      descriptors[prop] = desc = {\r\n        configurable: true,\r\n        enumerable: enumerable,\r\n        get: function get() {\r\n          var state = this[DRAFT_STATE];\r\n          assertUnrevoked(state); // @ts-ignore\r\n\r\n          return objectTraps.get(state, prop);\r\n        },\r\n        set: function set(value) {\r\n          var state = this[DRAFT_STATE];\r\n          assertUnrevoked(state); // @ts-ignore\r\n\r\n          objectTraps.set(state, prop, value);\r\n        }\r\n      };\r\n    }\r\n\r\n    return desc;\r\n  } // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\r\n\r\n\r\n  function markChangesSweep(drafts) {\r\n    // The natural order of drafts in the `scope` array is based on when they\r\n    // were accessed. By processing drafts in reverse natural order, we have a\r\n    // better chance of processing leaf nodes first. When a leaf node is known to\r\n    // have changed, we can avoid any traversal of its ancestor nodes.\r\n    for (var i = drafts.length - 1; i >= 0; i--) {\r\n      var state = drafts[i][DRAFT_STATE];\r\n\r\n      if (!state.modified_) {\r\n        switch (state.type_) {\r\n          case 5\r\n          /* ES5Array */\r\n          :\r\n            if (hasArrayChanges(state)) markChanged(state);\r\n            break;\r\n\r\n          case 4\r\n          /* ES5Object */\r\n          :\r\n            if (hasObjectChanges(state)) markChanged(state);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function markChangesRecursively(object) {\r\n    if (!object || typeof object !== \"object\") return;\r\n    var state = object[DRAFT_STATE];\r\n    if (!state) return;\r\n    var base_ = state.base_,\r\n        draft_ = state.draft_,\r\n        assigned_ = state.assigned_,\r\n        type_ = state.type_;\r\n\r\n    if (type_ === 4\r\n    /* ES5Object */\r\n    ) {\r\n        // Look for added keys.\r\n        // probably there is a faster way to detect changes, as sweep + recurse seems to do some\r\n        // unnecessary work.\r\n        // also: probably we can store the information we detect here, to speed up tree finalization!\r\n        each(draft_, function (key) {\r\n          if (key === DRAFT_STATE) return; // The `undefined` check is a fast path for pre-existing keys.\r\n\r\n          if (base_[key] === undefined && !has(base_, key)) {\r\n            assigned_[key] = true;\r\n            markChanged(state);\r\n          } else if (!assigned_[key]) {\r\n            // Only untouched properties trigger recursion.\r\n            markChangesRecursively(draft_[key]);\r\n          }\r\n        }); // Look for removed keys.\r\n\r\n        each(base_, function (key) {\r\n          // The `undefined` check is a fast path for pre-existing keys.\r\n          if (draft_[key] === undefined && !has(draft_, key)) {\r\n            assigned_[key] = false;\r\n            markChanged(state);\r\n          }\r\n        });\r\n      } else if (type_ === 5\r\n    /* ES5Array */\r\n    ) {\r\n        if (hasArrayChanges(state)) {\r\n          markChanged(state);\r\n          assigned_.length = true;\r\n        }\r\n\r\n        if (draft_.length < base_.length) {\r\n          for (var i = draft_.length; i < base_.length; i++) {\r\n            assigned_[i] = false;\r\n          }\r\n        } else {\r\n          for (var _i2 = base_.length; _i2 < draft_.length; _i2++) {\r\n            assigned_[_i2] = true;\r\n          }\r\n        } // Minimum count is enough, the other parts has been processed.\r\n\r\n\r\n        var min = Math.min(draft_.length, base_.length);\r\n\r\n        for (var _i3 = 0; _i3 < min; _i3++) {\r\n          // Only untouched indices trigger recursion.\r\n          if (!draft_.hasOwnProperty(_i3)) {\r\n            assigned_[_i3] = true;\r\n          }\r\n\r\n          if (assigned_[_i3] === undefined) markChangesRecursively(draft_[_i3]);\r\n        }\r\n      }\r\n  }\r\n\r\n  function hasObjectChanges(state) {\r\n    var base_ = state.base_,\r\n        draft_ = state.draft_; // Search for added keys and changed keys. Start at the back, because\r\n    // non-numeric keys are ordered by time of definition on the object.\r\n\r\n    var keys = ownKeys(draft_);\r\n\r\n    for (var i = keys.length - 1; i >= 0; i--) {\r\n      var key = keys[i];\r\n      if (key === DRAFT_STATE) continue;\r\n      var baseValue = base_[key]; // The `undefined` check is a fast path for pre-existing keys.\r\n\r\n      if (baseValue === undefined && !has(base_, key)) {\r\n        return true;\r\n      } // Once a base key is deleted, future changes go undetected, because its\r\n      // descriptor is erased. This branch detects any missed changes.\r\n      else {\r\n          var value = draft_[key];\r\n\r\n          var _state = value && value[DRAFT_STATE];\r\n\r\n          if (_state ? _state.base_ !== baseValue : !is(value, baseValue)) {\r\n            return true;\r\n          }\r\n        }\r\n    } // At this point, no keys were added or changed.\r\n    // Compare key count to determine if keys were deleted.\r\n\r\n\r\n    var baseIsDraft = !!base_[DRAFT_STATE];\r\n    return keys.length !== ownKeys(base_).length + (baseIsDraft ? 0 : 1); // + 1 to correct for DRAFT_STATE\r\n  }\r\n\r\n  function hasArrayChanges(state) {\r\n    var draft_ = state.draft_;\r\n    if (draft_.length !== state.base_.length) return true; // See #116\r\n    // If we first shorten the length, our array interceptors will be removed.\r\n    // If after that new items are added, result in the same original length,\r\n    // those last items will have no intercepting property.\r\n    // So if there is no own descriptor on the last position, we know that items were removed and added\r\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\r\n    // the last one\r\n    // last descriptor can be not a trap, if the array was extended\r\n\r\n    var descriptor = Object.getOwnPropertyDescriptor(draft_, draft_.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\r\n\r\n    if (descriptor && !descriptor.get) return true; // if we miss a property, it has been deleted, so array probobaly changed\r\n\r\n    for (var i = 0; i < draft_.length; i++) {\r\n      if (!draft_.hasOwnProperty(i)) return true;\r\n    } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\r\n\r\n\r\n    return false;\r\n  }\r\n\r\n  function hasChanges_(state) {\r\n    return state.type_ === 4\r\n    /* ES5Object */\r\n    ? hasObjectChanges(state) : hasArrayChanges(state);\r\n  }\r\n\r\n  function assertUnrevoked(state\r\n  /*ES5State | MapState | SetState*/\r\n  ) {\r\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\r\n  }\r\n\r\n  loadPlugin(\"ES5\", {\r\n    createES5Proxy_: createES5Proxy_,\r\n    willFinalizeES5_: willFinalizeES5_,\r\n    hasChanges_: hasChanges_\r\n  });\r\n}\r\n\r\nfunction enablePatches() {\r\n  var REPLACE = \"replace\";\r\n  var ADD = \"add\";\r\n  var REMOVE = \"remove\";\r\n\r\n  function generatePatches_(state, basePath, patches, inversePatches) {\r\n    switch (state.type_) {\r\n      case 0\r\n      /* ProxyObject */\r\n      :\r\n      case 4\r\n      /* ES5Object */\r\n      :\r\n      case 2\r\n      /* Map */\r\n      :\r\n        return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\r\n\r\n      case 5\r\n      /* ES5Array */\r\n      :\r\n      case 1\r\n      /* ProxyArray */\r\n      :\r\n        return generateArrayPatches(state, basePath, patches, inversePatches);\r\n\r\n      case 3\r\n      /* Set */\r\n      :\r\n        return generateSetPatches(state, basePath, patches, inversePatches);\r\n    }\r\n  }\r\n\r\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\r\n    var base_ = state.base_,\r\n        assigned_ = state.assigned_;\r\n    var copy_ = state.copy_; // Reduce complexity by ensuring `base` is never longer.\r\n\r\n    if (copy_.length < base_.length) {\r\n      var _ref = [copy_, base_];\r\n      base_ = _ref[0];\r\n      copy_ = _ref[1];\r\n      var _ref2 = [inversePatches, patches];\r\n      patches = _ref2[0];\r\n      inversePatches = _ref2[1];\r\n    } // Process replaced indices.\r\n\r\n\r\n    for (var i = 0; i < base_.length; i++) {\r\n      if (assigned_[i] && copy_[i] !== base_[i]) {\r\n        var path = basePath.concat([i]);\r\n        patches.push({\r\n          op: REPLACE,\r\n          path: path,\r\n          // Need to maybe clone it, as it can in fact be the original value\r\n          // due to the base/copy inversion at the start of this function\r\n          value: clonePatchValueIfNeeded(copy_[i])\r\n        });\r\n        inversePatches.push({\r\n          op: REPLACE,\r\n          path: path,\r\n          value: clonePatchValueIfNeeded(base_[i])\r\n        });\r\n      }\r\n    } // Process added indices.\r\n\r\n\r\n    for (var _i = base_.length; _i < copy_.length; _i++) {\r\n      var _path = basePath.concat([_i]);\r\n\r\n      patches.push({\r\n        op: ADD,\r\n        path: _path,\r\n        // Need to maybe clone it, as it can in fact be the original value\r\n        // due to the base/copy inversion at the start of this function\r\n        value: clonePatchValueIfNeeded(copy_[_i])\r\n      });\r\n    }\r\n\r\n    if (base_.length < copy_.length) {\r\n      inversePatches.push({\r\n        op: REPLACE,\r\n        path: basePath.concat([\"length\"]),\r\n        value: base_.length\r\n      });\r\n    }\r\n  } // This is used for both Map objects and normal objects.\r\n\r\n\r\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\r\n    var base_ = state.base_,\r\n        copy_ = state.copy_;\r\n    each(state.assigned_, function (key, assignedValue) {\r\n      var origValue = get(base_, key);\r\n      var value = get(copy_, key);\r\n      var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\r\n      if (origValue === value && op === REPLACE) return;\r\n      var path = basePath.concat(key);\r\n      patches.push(op === REMOVE ? {\r\n        op: op,\r\n        path: path\r\n      } : {\r\n        op: op,\r\n        path: path,\r\n        value: value\r\n      });\r\n      inversePatches.push(op === ADD ? {\r\n        op: REMOVE,\r\n        path: path\r\n      } : op === REMOVE ? {\r\n        op: ADD,\r\n        path: path,\r\n        value: clonePatchValueIfNeeded(origValue)\r\n      } : {\r\n        op: REPLACE,\r\n        path: path,\r\n        value: clonePatchValueIfNeeded(origValue)\r\n      });\r\n    });\r\n  }\r\n\r\n  function generateSetPatches(state, basePath, patches, inversePatches) {\r\n    var base_ = state.base_,\r\n        copy_ = state.copy_;\r\n    var i = 0;\r\n    base_.forEach(function (value) {\r\n      if (!copy_.has(value)) {\r\n        var path = basePath.concat([i]);\r\n        patches.push({\r\n          op: REMOVE,\r\n          path: path,\r\n          value: value\r\n        });\r\n        inversePatches.unshift({\r\n          op: ADD,\r\n          path: path,\r\n          value: value\r\n        });\r\n      }\r\n\r\n      i++;\r\n    });\r\n    i = 0;\r\n    copy_.forEach(function (value) {\r\n      if (!base_.has(value)) {\r\n        var path = basePath.concat([i]);\r\n        patches.push({\r\n          op: ADD,\r\n          path: path,\r\n          value: value\r\n        });\r\n        inversePatches.unshift({\r\n          op: REMOVE,\r\n          path: path,\r\n          value: value\r\n        });\r\n      }\r\n\r\n      i++;\r\n    });\r\n  }\r\n\r\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\r\n    patches.push({\r\n      op: REPLACE,\r\n      path: [],\r\n      value: replacement === NOTHING ? undefined : replacement\r\n    });\r\n    inversePatches.push({\r\n      op: REPLACE,\r\n      path: [],\r\n      value: baseValue\r\n    });\r\n  }\r\n\r\n  function applyPatches_(draft, patches) {\r\n    patches.forEach(function (patch) {\r\n      var path = patch.path,\r\n          op = patch.op;\r\n      var base = draft;\r\n\r\n      for (var i = 0; i < path.length - 1; i++) {\r\n        var parentType = getArchtype(base);\r\n        var p = path[i];\r\n\r\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\r\n          p = \"\" + p;\r\n        } // See #738, avoid prototype pollution\r\n\r\n\r\n        if ((parentType === 0\r\n        /* Object */\r\n        || parentType === 1\r\n        /* Array */\r\n        ) && (p === \"__proto__\" || p === \"constructor\")) die(24);\r\n        if (typeof base === \"function\" && p === \"prototype\") die(24);\r\n        base = get(base, p);\r\n        if (typeof base !== \"object\") die(15, path.join(\"/\"));\r\n      }\r\n\r\n      var type = getArchtype(base);\r\n      var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\r\n\r\n      var key = path[path.length - 1];\r\n\r\n      switch (op) {\r\n        case REPLACE:\r\n          switch (type) {\r\n            case 2\r\n            /* Map */\r\n            :\r\n              return base.set(key, value);\r\n\r\n            /* istanbul ignore next */\r\n\r\n            case 3\r\n            /* Set */\r\n            :\r\n              die(16);\r\n\r\n            default:\r\n              // if value is an object, then it's assigned by reference\r\n              // in the following add or remove ops, the value field inside the patch will also be modifyed\r\n              // so we use value from the cloned patch\r\n              // @ts-ignore\r\n              return base[key] = value;\r\n          }\r\n\r\n        case ADD:\r\n          switch (type) {\r\n            case 1\r\n            /* Array */\r\n            :\r\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\r\n\r\n            case 2\r\n            /* Map */\r\n            :\r\n              return base.set(key, value);\r\n\r\n            case 3\r\n            /* Set */\r\n            :\r\n              return base.add(value);\r\n\r\n            default:\r\n              return base[key] = value;\r\n          }\r\n\r\n        case REMOVE:\r\n          switch (type) {\r\n            case 1\r\n            /* Array */\r\n            :\r\n              return base.splice(key, 1);\r\n\r\n            case 2\r\n            /* Map */\r\n            :\r\n              return base.delete(key);\r\n\r\n            case 3\r\n            /* Set */\r\n            :\r\n              return base.delete(patch.value);\r\n\r\n            default:\r\n              return delete base[key];\r\n          }\r\n\r\n        default:\r\n          die(17, op);\r\n      }\r\n    });\r\n    return draft;\r\n  }\r\n\r\n  function deepClonePatchValue(obj) {\r\n    if (!isDraftable(obj)) return obj;\r\n    if (Array.isArray(obj)) return obj.map(deepClonePatchValue);\r\n    if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function (_ref3) {\r\n      var k = _ref3[0],\r\n          v = _ref3[1];\r\n      return [k, deepClonePatchValue(v)];\r\n    }));\r\n    if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));\r\n    var cloned = Object.create(Object.getPrototypeOf(obj));\r\n\r\n    for (var key in obj) {\r\n      cloned[key] = deepClonePatchValue(obj[key]);\r\n    }\r\n\r\n    if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];\r\n    return cloned;\r\n  }\r\n\r\n  function clonePatchValueIfNeeded(obj) {\r\n    if (isDraft(obj)) {\r\n      return deepClonePatchValue(obj);\r\n    } else return obj;\r\n  }\r\n\r\n  loadPlugin(\"Patches\", {\r\n    applyPatches_: applyPatches_,\r\n    generatePatches_: generatePatches_,\r\n    generateReplacementPatches_: generateReplacementPatches_\r\n  });\r\n}\r\n\r\n// types only!\r\nfunction enableMapSet() {\r\n  /* istanbul ignore next */\r\n  var _extendStatics = function extendStatics(d, b) {\r\n    _extendStatics = Object.setPrototypeOf || {\r\n      __proto__: []\r\n    } instanceof Array && function (d, b) {\r\n      d.__proto__ = b;\r\n    } || function (d, b) {\r\n      for (var p in b) {\r\n        if (b.hasOwnProperty(p)) d[p] = b[p];\r\n      }\r\n    };\r\n\r\n    return _extendStatics(d, b);\r\n  }; // Ugly hack to resolve #502 and inherit built in Map / Set\r\n\r\n\r\n  function __extends(d, b) {\r\n    _extendStatics(d, b);\r\n\r\n    function __() {\r\n      this.constructor = d;\r\n    }\r\n\r\n    d.prototype = ( // @ts-ignore\r\n    __.prototype = b.prototype, new __());\r\n  }\r\n\r\n  var DraftMap = function (_super) {\r\n    __extends(DraftMap, _super); // Create class manually, cause #502\r\n\r\n\r\n    function DraftMap(target, parent) {\r\n      this[DRAFT_STATE] = {\r\n        type_: 2\r\n        /* Map */\r\n        ,\r\n        parent_: parent,\r\n        scope_: parent ? parent.scope_ : getCurrentScope(),\r\n        modified_: false,\r\n        finalized_: false,\r\n        copy_: undefined,\r\n        assigned_: undefined,\r\n        base_: target,\r\n        draft_: this,\r\n        isManual_: false,\r\n        revoked_: false\r\n      };\r\n      return this;\r\n    }\r\n\r\n    var p = DraftMap.prototype;\r\n    Object.defineProperty(p, \"size\", {\r\n      get: function get() {\r\n        return latest(this[DRAFT_STATE]).size;\r\n      } // enumerable: false,\r\n      // configurable: true\r\n\r\n    });\r\n\r\n    p.has = function (key) {\r\n      return latest(this[DRAFT_STATE]).has(key);\r\n    };\r\n\r\n    p.set = function (key, value) {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n\r\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\r\n        prepareMapCopy(state);\r\n        markChanged(state);\r\n        state.assigned_.set(key, true);\r\n        state.copy_.set(key, value);\r\n        state.assigned_.set(key, true);\r\n      }\r\n\r\n      return this;\r\n    };\r\n\r\n    p.delete = function (key) {\r\n      if (!this.has(key)) {\r\n        return false;\r\n      }\r\n\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareMapCopy(state);\r\n      markChanged(state);\r\n\r\n      if (state.base_.has(key)) {\r\n        state.assigned_.set(key, false);\r\n      } else {\r\n        state.assigned_.delete(key);\r\n      }\r\n\r\n      state.copy_.delete(key);\r\n      return true;\r\n    };\r\n\r\n    p.clear = function () {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n\r\n      if (latest(state).size) {\r\n        prepareMapCopy(state);\r\n        markChanged(state);\r\n        state.assigned_ = new Map();\r\n        each(state.base_, function (key) {\r\n          state.assigned_.set(key, false);\r\n        });\r\n        state.copy_.clear();\r\n      }\r\n    };\r\n\r\n    p.forEach = function (cb, thisArg) {\r\n      var _this = this;\r\n\r\n      var state = this[DRAFT_STATE];\r\n      latest(state).forEach(function (_value, key, _map) {\r\n        cb.call(thisArg, _this.get(key), key, _this);\r\n      });\r\n    };\r\n\r\n    p.get = function (key) {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      var value = latest(state).get(key);\r\n\r\n      if (state.finalized_ || !isDraftable(value)) {\r\n        return value;\r\n      }\r\n\r\n      if (value !== state.base_.get(key)) {\r\n        return value; // either already drafted or reassigned\r\n      } // despite what it looks, this creates a draft only once, see above condition\r\n\r\n\r\n      var draft = createProxy(state.scope_.immer_, value, state);\r\n      prepareMapCopy(state);\r\n      state.copy_.set(key, draft);\r\n      return draft;\r\n    };\r\n\r\n    p.keys = function () {\r\n      return latest(this[DRAFT_STATE]).keys();\r\n    };\r\n\r\n    p.values = function () {\r\n      var _this2 = this,\r\n          _ref;\r\n\r\n      var iterator = this.keys();\r\n      return _ref = {}, _ref[iteratorSymbol] = function () {\r\n        return _this2.values();\r\n      }, _ref.next = function next() {\r\n        var r = iterator.next();\r\n        /* istanbul ignore next */\r\n\r\n        if (r.done) return r;\r\n\r\n        var value = _this2.get(r.value);\r\n\r\n        return {\r\n          done: false,\r\n          value: value\r\n        };\r\n      }, _ref;\r\n    };\r\n\r\n    p.entries = function () {\r\n      var _this3 = this,\r\n          _ref2;\r\n\r\n      var iterator = this.keys();\r\n      return _ref2 = {}, _ref2[iteratorSymbol] = function () {\r\n        return _this3.entries();\r\n      }, _ref2.next = function next() {\r\n        var r = iterator.next();\r\n        /* istanbul ignore next */\r\n\r\n        if (r.done) return r;\r\n\r\n        var value = _this3.get(r.value);\r\n\r\n        return {\r\n          done: false,\r\n          value: [r.value, value]\r\n        };\r\n      }, _ref2;\r\n    };\r\n\r\n    p[iteratorSymbol] = function () {\r\n      return this.entries();\r\n    };\r\n\r\n    return DraftMap;\r\n  }(Map);\r\n\r\n  function proxyMap_(target, parent) {\r\n    // @ts-ignore\r\n    return new DraftMap(target, parent);\r\n  }\r\n\r\n  function prepareMapCopy(state) {\r\n    if (!state.copy_) {\r\n      state.assigned_ = new Map();\r\n      state.copy_ = new Map(state.base_);\r\n    }\r\n  }\r\n\r\n  var DraftSet = function (_super) {\r\n    __extends(DraftSet, _super); // Create class manually, cause #502\r\n\r\n\r\n    function DraftSet(target, parent) {\r\n      this[DRAFT_STATE] = {\r\n        type_: 3\r\n        /* Set */\r\n        ,\r\n        parent_: parent,\r\n        scope_: parent ? parent.scope_ : getCurrentScope(),\r\n        modified_: false,\r\n        finalized_: false,\r\n        copy_: undefined,\r\n        base_: target,\r\n        draft_: this,\r\n        drafts_: new Map(),\r\n        revoked_: false,\r\n        isManual_: false\r\n      };\r\n      return this;\r\n    }\r\n\r\n    var p = DraftSet.prototype;\r\n    Object.defineProperty(p, \"size\", {\r\n      get: function get() {\r\n        return latest(this[DRAFT_STATE]).size;\r\n      } // enumerable: true,\r\n\r\n    });\r\n\r\n    p.has = function (value) {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\r\n\r\n      if (!state.copy_) {\r\n        return state.base_.has(value);\r\n      }\r\n\r\n      if (state.copy_.has(value)) return true;\r\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;\r\n      return false;\r\n    };\r\n\r\n    p.add = function (value) {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n\r\n      if (!this.has(value)) {\r\n        prepareSetCopy(state);\r\n        markChanged(state);\r\n        state.copy_.add(value);\r\n      }\r\n\r\n      return this;\r\n    };\r\n\r\n    p.delete = function (value) {\r\n      if (!this.has(value)) {\r\n        return false;\r\n      }\r\n\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareSetCopy(state);\r\n      markChanged(state);\r\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) :\r\n      /* istanbul ignore next */\r\n      false);\r\n    };\r\n\r\n    p.clear = function () {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n\r\n      if (latest(state).size) {\r\n        prepareSetCopy(state);\r\n        markChanged(state);\r\n        state.copy_.clear();\r\n      }\r\n    };\r\n\r\n    p.values = function () {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareSetCopy(state);\r\n      return state.copy_.values();\r\n    };\r\n\r\n    p.entries = function entries() {\r\n      var state = this[DRAFT_STATE];\r\n      assertUnrevoked(state);\r\n      prepareSetCopy(state);\r\n      return state.copy_.entries();\r\n    };\r\n\r\n    p.keys = function () {\r\n      return this.values();\r\n    };\r\n\r\n    p[iteratorSymbol] = function () {\r\n      return this.values();\r\n    };\r\n\r\n    p.forEach = function forEach(cb, thisArg) {\r\n      var iterator = this.values();\r\n      var result = iterator.next();\r\n\r\n      while (!result.done) {\r\n        cb.call(thisArg, result.value, result.value, this);\r\n        result = iterator.next();\r\n      }\r\n    };\r\n\r\n    return DraftSet;\r\n  }(Set);\r\n\r\n  function proxySet_(target, parent) {\r\n    // @ts-ignore\r\n    return new DraftSet(target, parent);\r\n  }\r\n\r\n  function prepareSetCopy(state) {\r\n    if (!state.copy_) {\r\n      // create drafts for all entries to preserve insertion order\r\n      state.copy_ = new Set();\r\n      state.base_.forEach(function (value) {\r\n        if (isDraftable(value)) {\r\n          var draft = createProxy(state.scope_.immer_, value, state);\r\n          state.drafts_.set(value, draft);\r\n          state.copy_.add(draft);\r\n        } else {\r\n          state.copy_.add(value);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  function assertUnrevoked(state\r\n  /*ES5State | MapState | SetState*/\r\n  ) {\r\n    if (state.revoked_) die(3, JSON.stringify(latest(state)));\r\n  }\r\n\r\n  loadPlugin(\"MapSet\", {\r\n    proxyMap_: proxyMap_,\r\n    proxySet_: proxySet_\r\n  });\r\n}\r\n\r\nfunction enableAllPlugins() {\r\n  enableES5();\r\n  enableMapSet();\r\n  enablePatches();\r\n}\r\n\r\nvar immer =\r\n/*#__PURE__*/\r\nnew Immer();\r\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\r\n\r\nvar produce = immer.produce;\r\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\r\n\r\nvar produceWithPatches =\r\n/*#__PURE__*/\r\nimmer.produceWithPatches.bind(immer);\r\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * Always freeze by default, even in production mode\r\n */\r\n\r\nvar setAutoFreeze =\r\n/*#__PURE__*/\r\nimmer.setAutoFreeze.bind(immer);\r\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\r\n\r\nvar setUseProxies =\r\n/*#__PURE__*/\r\nimmer.setUseProxies.bind(immer);\r\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\r\n\r\nvar applyPatches =\r\n/*#__PURE__*/\r\nimmer.applyPatches.bind(immer);\r\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\r\n\r\nvar createDraft =\r\n/*#__PURE__*/\r\nimmer.createDraft.bind(immer);\r\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\r\n\r\nvar finishDraft =\r\n/*#__PURE__*/\r\nimmer.finishDraft.bind(immer);\r\n/**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\r\n\r\nfunction castDraft(value) {\r\n  return value;\r\n}\r\n/**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\r\n\r\nfunction castImmutable(value) {\r\n  return value;\r\n}\r\n\r\nexports.Immer = Immer;\r\nexports.applyPatches = applyPatches;\r\nexports.castDraft = castDraft;\r\nexports.castImmutable = castImmutable;\r\nexports.createDraft = createDraft;\r\nexports.current = current;\r\nexports[\"default\"] = produce;\r\nexports.enableAllPlugins = enableAllPlugins;\r\nexports.enableES5 = enableES5;\r\nexports.enableMapSet = enableMapSet;\r\nexports.enablePatches = enablePatches;\r\nexports.finishDraft = finishDraft;\r\nexports.freeze = freeze;\r\nexports.immerable = DRAFTABLE;\r\nexports.isDraft = isDraft;\r\nexports.isDraftable = isDraftable;\r\nexports.nothing = NOTHING;\r\nexports.original = original;\r\nexports.produce = produce;\r\nexports.produceWithPatches = produceWithPatches;\r\nexports.setAutoFreeze = setAutoFreeze;\r\nexports.setUseProxies = setUseProxies;\r\n//# sourceMappingURL=immer.cjs.development.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNB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O0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQjtBQUNwQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2Ysa0JBQWU7QUFDZix3QkFBd0I7QUFDeEIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250LWVuZC8uL25vZGVfbW9kdWxlcy9pbW1lci9kaXN0L2ltbWVyLmNqcy5kZXZlbG9wbWVudC5qcz8zZmVhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG52YXIgX3JlZjtcclxuXHJcbi8vIFNob3VsZCBiZSBubyBpbXBvcnRzIGhlcmUhXHJcbi8vIFNvbWUgdGhpbmdzIHRoYXQgc2hvdWxkIGJlIGV2YWx1YXRlZCBiZWZvcmUgYWxsIGVsc2UuLi5cclxuLy8gV2Ugb25seSB3YW50IHRvIGtub3cgaWYgbm9uLXBvbHlmaWxsZWQgc3ltYm9scyBhcmUgYXZhaWxhYmxlXHJcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZlxyXG4vKiNfX1BVUkVfXyovXHJcblN5bWJvbChcInhcIikgPT09IFwic3ltYm9sXCI7XHJcbnZhciBoYXNNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiO1xyXG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIjtcclxudmFyIGhhc1Byb3hpZXMgPSB0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFByb3h5LnJldm9jYWJsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIjtcclxuLyoqXHJcbiAqIFRoZSBzZW50aW5lbCB2YWx1ZSByZXR1cm5lZCBieSBwcm9kdWNlcnMgdG8gcmVwbGFjZSB0aGUgZHJhZnQgd2l0aCB1bmRlZmluZWQuXHJcbiAqL1xyXG5cclxudmFyIE5PVEhJTkcgPSBoYXNTeW1ib2wgP1xyXG4vKiNfX1BVUkVfXyovXHJcblN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpIDogKF9yZWYgPSB7fSwgX3JlZltcImltbWVyLW5vdGhpbmdcIl0gPSB0cnVlLCBfcmVmKTtcclxuLyoqXHJcbiAqIFRvIGxldCBJbW1lciB0cmVhdCB5b3VyIGNsYXNzIGluc3RhbmNlcyBhcyBwbGFpbiBpbW11dGFibGUgb2JqZWN0c1xyXG4gKiAoYWxiZWl0IHdpdGggYSBjdXN0b20gcHJvdG90eXBlKSwgeW91IG11c3QgZGVmaW5lIGVpdGhlciBhbiBpbnN0YW5jZSBwcm9wZXJ0eVxyXG4gKiBvciBhIHN0YXRpYyBwcm9wZXJ0eSBvbiBlYWNoIG9mIHlvdXIgY3VzdG9tIGNsYXNzZXMuXHJcbiAqXHJcbiAqIE90aGVyd2lzZSwgeW91ciBjbGFzcyBpbnN0YW5jZSB3aWxsIG5ldmVyIGJlIGRyYWZ0ZWQsIHdoaWNoIG1lYW5zIGl0IHdvbid0IGJlXHJcbiAqIHNhZmUgdG8gbXV0YXRlIGluIGEgcHJvZHVjZSBjYWxsYmFjay5cclxuICovXHJcblxyXG52YXIgRFJBRlRBQkxFID0gaGFzU3ltYm9sID9cclxuLyojX19QVVJFX18qL1xyXG5TeW1ib2wuZm9yKFwiaW1tZXItZHJhZnRhYmxlXCIpIDogXCJfXyRpbW1lcl9kcmFmdGFibGVcIjtcclxudmFyIERSQUZUX1NUQVRFID0gaGFzU3ltYm9sID9cclxuLyojX19QVVJFX18qL1xyXG5TeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIikgOiBcIl9fJGltbWVyX3N0YXRlXCI7IC8vIEV2ZW4gYSBwb2x5ZmlsbGVkIFN5bWJvbCBtaWdodCBwcm92aWRlIFN5bWJvbC5pdGVyYXRvclxyXG5cclxudmFyIGl0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcclxuXHJcbnZhciBlcnJvcnMgPSB7XHJcbiAgMDogXCJJbGxlZ2FsIHN0YXRlXCIsXHJcbiAgMTogXCJJbW1lciBkcmFmdHMgY2Fubm90IGhhdmUgY29tcHV0ZWQgcHJvcGVydGllc1wiLFxyXG4gIDI6IFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcclxuICAzOiBmdW5jdGlvbiBfKGRhdGEpIHtcclxuICAgIHJldHVybiBcIkNhbm5vdCB1c2UgYSBwcm94eSB0aGF0IGhhcyBiZWVuIHJldm9rZWQuIERpZCB5b3UgcGFzcyBhbiBvYmplY3QgZnJvbSBpbnNpZGUgYW4gaW1tZXIgZnVuY3Rpb24gdG8gYW4gYXN5bmMgcHJvY2Vzcz8gXCIgKyBkYXRhO1xyXG4gIH0sXHJcbiAgNDogXCJBbiBpbW1lciBwcm9kdWNlciByZXR1cm5lZCBhIG5ldyB2YWx1ZSAqYW5kKiBtb2RpZmllZCBpdHMgZHJhZnQuIEVpdGhlciByZXR1cm4gYSBuZXcgdmFsdWUgKm9yKiBtb2RpZnkgdGhlIGRyYWZ0LlwiLFxyXG4gIDU6IFwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsXHJcbiAgNjogXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcclxuICA3OiBcIlRoZSB0aGlyZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIHVuZGVmaW5lZFwiLFxyXG4gIDg6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLFxyXG4gIDk6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxyXG4gIDEwOiBcIlRoZSBnaXZlbiBkcmFmdCBpcyBhbHJlYWR5IGZpbmFsaXplZFwiLFxyXG4gIDExOiBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXHJcbiAgMTI6IFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcclxuICAxMzogXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIixcclxuICAxNDogXCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsXHJcbiAgMTU6IGZ1bmN0aW9uIF8ocGF0aCkge1xyXG4gICAgcmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoO1xyXG4gIH0sXHJcbiAgMTY6ICdTZXRzIGNhbm5vdCBoYXZlIFwicmVwbGFjZVwiIHBhdGNoZXMuJyxcclxuICAxNzogZnVuY3Rpb24gXyhvcCkge1xyXG4gICAgcmV0dXJuIFwiVW5zdXBwb3J0ZWQgcGF0Y2ggb3BlcmF0aW9uOiBcIiArIG9wO1xyXG4gIH0sXHJcbiAgMTg6IGZ1bmN0aW9uIF8ocGx1Z2luKSB7XHJcbiAgICByZXR1cm4gXCJUaGUgcGx1Z2luIGZvciAnXCIgKyBwbHVnaW4gKyBcIicgaGFzIG5vdCBiZWVuIGxvYWRlZCBpbnRvIEltbWVyLiBUbyBlbmFibGUgdGhlIHBsdWdpbiwgaW1wb3J0IGFuZCBjYWxsIGBlbmFibGVcIiArIHBsdWdpbiArIFwiKClgIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgYXBwbGljYXRpb24uXCI7XHJcbiAgfSxcclxuICAyMDogXCJDYW5ub3QgdXNlIHByb3hpZXMgaWYgUHJveHksIFByb3h5LnJldm9jYWJsZSBvciBSZWZsZWN0IGFyZSBub3QgYXZhaWxhYmxlXCIsXHJcbiAgMjE6IGZ1bmN0aW9uIF8odGhpbmcpIHtcclxuICAgIHJldHVybiBcInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiICsgdGhpbmcgKyBcIidcIjtcclxuICB9LFxyXG4gIDIyOiBmdW5jdGlvbiBfKHRoaW5nKSB7XHJcbiAgICByZXR1cm4gXCInY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiICsgdGhpbmc7XHJcbiAgfSxcclxuICAyMzogZnVuY3Rpb24gXyh0aGluZykge1xyXG4gICAgcmV0dXJuIFwiJ29yaWdpbmFsJyBleHBlY3RzIGEgZHJhZnQsIGdvdDogXCIgKyB0aGluZztcclxuICB9LFxyXG4gIDI0OiBcIlBhdGNoaW5nIHJlc2VydmVkIGF0dHJpYnV0ZXMgbGlrZSBfX3Byb3RvX18sIHByb3RvdHlwZSBhbmQgY29uc3RydWN0b3IgaXMgbm90IGFsbG93ZWRcIlxyXG59O1xyXG5mdW5jdGlvbiBkaWUoZXJyb3IpIHtcclxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XHJcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICB9XHJcblxyXG4gIHtcclxuICAgIHZhciBlID0gZXJyb3JzW2Vycm9yXTtcclxuICAgIHZhciBtc2cgPSAhZSA/IFwidW5rbm93biBlcnJvciBucjogXCIgKyBlcnJvciA6IHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCIgPyBlLmFwcGx5KG51bGwsIGFyZ3MpIDogZTtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIltJbW1lcl0gXCIgKyBtc2cpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gSW1tZXIgZHJhZnQgKi9cclxuXHJcbi8qI19fUFVSRV9fKi9cclxuXHJcbmZ1bmN0aW9uIGlzRHJhZnQodmFsdWUpIHtcclxuICByZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXTtcclxufVxyXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgZHJhZnRlZCBieSBJbW1lciAqL1xyXG5cclxuLyojX19QVVJFX18qL1xyXG5cclxuZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWUpIHtcclxuICB2YXIgX3ZhbHVlJGNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XHJcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICEhdmFsdWVbRFJBRlRBQkxFXSB8fCAhISgoX3ZhbHVlJGNvbnN0cnVjdG9yID0gdmFsdWUuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF92YWx1ZSRjb25zdHJ1Y3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ZhbHVlJGNvbnN0cnVjdG9yW0RSQUZUQUJMRV0pIHx8IGlzTWFwKHZhbHVlKSB8fCBpc1NldCh2YWx1ZSk7XHJcbn1cclxudmFyIG9iamVjdEN0b3JTdHJpbmcgPVxyXG4vKiNfX1BVUkVfXyovXHJcbk9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcclxuLyojX19QVVJFX18qL1xyXG5cclxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xyXG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XHJcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcclxuXHJcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIHZhciBDdG9yID0gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocHJvdG8sIFwiY29uc3RydWN0b3JcIikgJiYgcHJvdG8uY29uc3RydWN0b3I7XHJcbiAgaWYgKEN0b3IgPT09IE9iamVjdCkgcmV0dXJuIHRydWU7XHJcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nO1xyXG59XHJcbmZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlKSB7XHJcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSkgZGllKDIzLCB2YWx1ZSk7XHJcbiAgcmV0dXJuIHZhbHVlW0RSQUZUX1NUQVRFXS5iYXNlXztcclxufVxyXG4vKiNfX1BVUkVfXyovXHJcblxyXG52YXIgb3duS2V5cyA9IHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5cyA/IFJlZmxlY3Qub3duS2V5cyA6IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gKG9iaikge1xyXG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikpO1xyXG59IDpcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XHJcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQpIHtcclxuICAvLyBQb2x5ZmlsbCBuZWVkZWQgZm9yIEhlcm1lcyBhbmQgSUUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svaGVybWVzL2lzc3Vlcy8yNzRcclxuICB2YXIgcmVzID0ge307XHJcbiAgb3duS2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgcmVzW2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcclxuICB9KTtcclxuICByZXR1cm4gcmVzO1xyXG59O1xyXG5mdW5jdGlvbiBlYWNoKG9iaiwgaXRlciwgZW51bWVyYWJsZU9ubHkpIHtcclxuICBpZiAoZW51bWVyYWJsZU9ubHkgPT09IHZvaWQgMCkge1xyXG4gICAgZW51bWVyYWJsZU9ubHkgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIGlmIChnZXRBcmNodHlwZShvYmopID09PSAwXHJcbiAgLyogT2JqZWN0ICovXHJcbiAgKSB7XHJcbiAgICAgIChlbnVtZXJhYmxlT25seSA/IE9iamVjdC5rZXlzIDogb3duS2V5cykob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoIWVudW1lcmFibGVPbmx5IHx8IHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIpIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICByZXR1cm4gaXRlcihpbmRleCwgZW50cnksIG9iaik7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuLyojX19QVVJFX18qL1xyXG5cclxuZnVuY3Rpb24gZ2V0QXJjaHR5cGUodGhpbmcpIHtcclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gIHZhciBzdGF0ZSA9IHRoaW5nW0RSQUZUX1NUQVRFXTtcclxuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS50eXBlXyA+IDMgPyBzdGF0ZS50eXBlXyAtIDQgLy8gY2F1c2UgT2JqZWN0IGFuZCBBcnJheSBtYXAgYmFjayBmcm9tIDQgYW5kIDVcclxuICA6IHN0YXRlLnR5cGVfIC8vIG90aGVycyBhcmUgdGhlIHNhbWVcclxuICA6IEFycmF5LmlzQXJyYXkodGhpbmcpID8gMVxyXG4gIC8qIEFycmF5ICovXHJcbiAgOiBpc01hcCh0aGluZykgPyAyXHJcbiAgLyogTWFwICovXHJcbiAgOiBpc1NldCh0aGluZykgPyAzXHJcbiAgLyogU2V0ICovXHJcbiAgOiAwXHJcbiAgLyogT2JqZWN0ICovXHJcbiAgO1xyXG59XHJcbi8qI19fUFVSRV9fKi9cclxuXHJcbmZ1bmN0aW9uIGhhcyh0aGluZywgcHJvcCkge1xyXG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDJcclxuICAvKiBNYXAgKi9cclxuICA/IHRoaW5nLmhhcyhwcm9wKSA6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcCk7XHJcbn1cclxuLyojX19QVVJFX18qL1xyXG5cclxuZnVuY3Rpb24gZ2V0KHRoaW5nLCBwcm9wKSB7XHJcbiAgLy8gQHRzLWlnbm9yZVxyXG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDJcclxuICAvKiBNYXAgKi9cclxuICA/IHRoaW5nLmdldChwcm9wKSA6IHRoaW5nW3Byb3BdO1xyXG59XHJcbi8qI19fUFVSRV9fKi9cclxuXHJcbmZ1bmN0aW9uIHNldCh0aGluZywgcHJvcE9yT2xkVmFsdWUsIHZhbHVlKSB7XHJcbiAgdmFyIHQgPSBnZXRBcmNodHlwZSh0aGluZyk7XHJcbiAgaWYgKHQgPT09IDJcclxuICAvKiBNYXAgKi9cclxuICApIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpO2Vsc2UgaWYgKHQgPT09IDNcclxuICAvKiBTZXQgKi9cclxuICApIHtcclxuICAgICAgdGhpbmcuYWRkKHZhbHVlKTtcclxuICAgIH0gZWxzZSB0aGluZ1twcm9wT3JPbGRWYWx1ZV0gPSB2YWx1ZTtcclxufVxyXG4vKiNfX1BVUkVfXyovXHJcblxyXG5mdW5jdGlvbiBpcyh4LCB5KSB7XHJcbiAgLy8gRnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9jNjk5MDRhNTExYjkwMDI2NjkzNTE2ODIyMzA2M2RkODc3MmRmYzQwL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvc2hhbGxvd0VxdWFsLmpzXHJcbiAgaWYgKHggPT09IHkpIHtcclxuICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcclxuICB9XHJcbn1cclxuLyojX19QVVJFX18qL1xyXG5cclxuZnVuY3Rpb24gaXNNYXAodGFyZ2V0KSB7XHJcbiAgcmV0dXJuIGhhc01hcCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBNYXA7XHJcbn1cclxuLyojX19QVVJFX18qL1xyXG5cclxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XHJcbiAgcmV0dXJuIGhhc1NldCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBTZXQ7XHJcbn1cclxuLyojX19QVVJFX18qL1xyXG5cclxuZnVuY3Rpb24gbGF0ZXN0KHN0YXRlKSB7XHJcbiAgcmV0dXJuIHN0YXRlLmNvcHlfIHx8IHN0YXRlLmJhc2VfO1xyXG59XHJcbi8qI19fUFVSRV9fKi9cclxuXHJcbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KGJhc2UpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShiYXNlKSkgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJhc2UpO1xyXG4gIHZhciBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XHJcbiAgZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFXTtcclxuICB2YXIga2V5cyA9IG93bktleXMoZGVzY3JpcHRvcnMpO1xyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgdmFyIGRlc2MgPSBkZXNjcmlwdG9yc1trZXldO1xyXG5cclxuICAgIGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xyXG4gICAgICBkZXNjLndyaXRhYmxlID0gdHJ1ZTtcclxuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSB0cnVlO1xyXG4gICAgfSAvLyBsaWtlIG9iamVjdC5hc3NpZ24sIHdlIHdpbGwgcmVhZCBhbnkgX293bl8sIGdldC9zZXQgYWNjZXNzb3JzLiBUaGlzIGhlbHBzIGluIGRlYWxpbmdcclxuICAgIC8vIHdpdGggbGlicmFyaWVzIHRoYXQgdHJhcCB2YWx1ZXMsIGxpa2UgbW9ieCBvciB2dWVcclxuICAgIC8vIHVubGlrZSBvYmplY3QuYXNzaWduLCBub24tZW51bWVyYWJsZXMgd2lsbCBiZSBjb3BpZWQgYXMgd2VsbFxyXG5cclxuXHJcbiAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpIGRlc2NyaXB0b3JzW2tleV0gPSB7XHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcclxuICAgICAgdmFsdWU6IGJhc2Vba2V5XVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpO1xyXG59XHJcbmZ1bmN0aW9uIGZyZWV6ZShvYmosIGRlZXApIHtcclxuICBpZiAoZGVlcCA9PT0gdm9pZCAwKSB7XHJcbiAgICBkZWVwID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNGcm96ZW4ob2JqKSB8fCBpc0RyYWZ0KG9iaikgfHwgIWlzRHJhZnRhYmxlKG9iaikpIHJldHVybiBvYmo7XHJcblxyXG4gIGlmIChnZXRBcmNodHlwZShvYmopID4gMVxyXG4gIC8qIE1hcCBvciBTZXQgKi9cclxuICApIHtcclxuICAgICAgb2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zO1xyXG4gICAgfVxyXG5cclxuICBPYmplY3QuZnJlZXplKG9iaik7XHJcbiAgaWYgKGRlZXApIGVhY2gob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGZyZWV6ZSh2YWx1ZSwgdHJ1ZSk7XHJcbiAgfSwgdHJ1ZSk7XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xyXG4gIGRpZSgyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNGcm96ZW4ob2JqKSB7XHJcbiAgaWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHJldHVybiB0cnVlOyAvLyBTZWUgIzYwMCwgSUUgZGllcyBvbiBub24tb2JqZWN0cyBpbiBPYmplY3QuaXNGcm96ZW5cclxuXHJcbiAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbihvYmopO1xyXG59XHJcblxyXG4vKiogUGx1Z2luIHV0aWxpdGllcyAqL1xyXG5cclxudmFyIHBsdWdpbnMgPSB7fTtcclxuZnVuY3Rpb24gZ2V0UGx1Z2luKHBsdWdpbktleSkge1xyXG4gIHZhciBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV07XHJcblxyXG4gIGlmICghcGx1Z2luKSB7XHJcbiAgICBkaWUoMTgsIHBsdWdpbktleSk7XHJcbiAgfSAvLyBAdHMtaWdub3JlXHJcblxyXG5cclxuICByZXR1cm4gcGx1Z2luO1xyXG59XHJcbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luS2V5LCBpbXBsZW1lbnRhdGlvbikge1xyXG4gIGlmICghcGx1Z2luc1twbHVnaW5LZXldKSBwbHVnaW5zW3BsdWdpbktleV0gPSBpbXBsZW1lbnRhdGlvbjtcclxufVxyXG5cclxudmFyIGN1cnJlbnRTY29wZTtcclxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xyXG4gIGlmICggIWN1cnJlbnRTY29wZSkgZGllKDApO1xyXG4gIHJldHVybiBjdXJyZW50U2NvcGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVNjb3BlKHBhcmVudF8sIGltbWVyXykge1xyXG4gIHJldHVybiB7XHJcbiAgICBkcmFmdHNfOiBbXSxcclxuICAgIHBhcmVudF86IHBhcmVudF8sXHJcbiAgICBpbW1lcl86IGltbWVyXyxcclxuICAgIC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2VcclxuICAgIC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXHJcbiAgICBjYW5BdXRvRnJlZXplXzogdHJ1ZSxcclxuICAgIHVuZmluYWxpemVkRHJhZnRzXzogMFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKSB7XHJcbiAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcclxuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7IC8vIGFzc2VydCB3ZSBoYXZlIHRoZSBwbHVnaW5cclxuXHJcbiAgICBzY29wZS5wYXRjaGVzXyA9IFtdO1xyXG4gICAgc2NvcGUuaW52ZXJzZVBhdGNoZXNfID0gW107XHJcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XHJcbiAgbGVhdmVTY29wZShzY29wZSk7XHJcbiAgc2NvcGUuZHJhZnRzXy5mb3JFYWNoKHJldm9rZURyYWZ0KTsgLy8gQHRzLWlnbm9yZVxyXG5cclxuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBsZWF2ZVNjb3BlKHNjb3BlKSB7XHJcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcclxuICAgIGN1cnJlbnRTY29wZSA9IHNjb3BlLnBhcmVudF87XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXIpIHtcclxuICByZXR1cm4gY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJldm9rZURyYWZ0KGRyYWZ0KSB7XHJcbiAgdmFyIHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdO1xyXG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMFxyXG4gIC8qIFByb3h5T2JqZWN0ICovXHJcbiAgfHwgc3RhdGUudHlwZV8gPT09IDFcclxuICAvKiBQcm94eUFycmF5ICovXHJcbiAgKSBzdGF0ZS5yZXZva2VfKCk7ZWxzZSBzdGF0ZS5yZXZva2VkXyA9IHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSkge1xyXG4gIHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoO1xyXG4gIHZhciBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xyXG4gIHZhciBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnQ7XHJcbiAgaWYgKCFzY29wZS5pbW1lcl8udXNlUHJveGllc18pIGdldFBsdWdpbihcIkVTNVwiKS53aWxsRmluYWxpemVFUzVfKHNjb3BlLCByZXN1bHQsIGlzUmVwbGFjZWQpO1xyXG5cclxuICBpZiAoaXNSZXBsYWNlZCkge1xyXG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XHJcbiAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcclxuICAgICAgZGllKDQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XHJcbiAgICAgIC8vIEZpbmFsaXplIHRoZSByZXN1bHQgaW4gY2FzZSBpdCBjb250YWlucyAob3IgaXMpIGEgc3Vic2V0IG9mIHRoZSBkcmFmdC5cclxuICAgICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIHJlc3VsdCk7XHJcbiAgICAgIGlmICghc2NvcGUucGFyZW50XykgbWF5YmVGcmVlemUoc2NvcGUsIHJlc3VsdCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XHJcbiAgICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sIHJlc3VsdCwgc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIEZpbmFsaXplIHRoZSBiYXNlIGRyYWZ0LlxyXG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xyXG4gIH1cclxuXHJcbiAgcmV2b2tlU2NvcGUoc2NvcGUpO1xyXG5cclxuICBpZiAoc2NvcGUucGF0Y2hlc18pIHtcclxuICAgIHNjb3BlLnBhdGNoTGlzdGVuZXJfKHNjb3BlLnBhdGNoZXNfLCBzY29wZS5pbnZlcnNlUGF0Y2hlc18pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmluYWxpemUocm9vdFNjb3BlLCB2YWx1ZSwgcGF0aCkge1xyXG4gIC8vIERvbid0IHJlY3Vyc2UgaW4gdGhvIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXNcclxuICBpZiAoaXNGcm96ZW4odmFsdWUpKSByZXR1cm4gdmFsdWU7XHJcbiAgdmFyIHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdOyAvLyBBIHBsYWluIG9iamVjdCwgbWlnaHQgbmVlZCBmcmVlemluZywgbWlnaHQgY29udGFpbiBkcmFmdHNcclxuXHJcbiAgaWYgKCFzdGF0ZSkge1xyXG4gICAgZWFjaCh2YWx1ZSwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKTtcclxuICAgIH0sIHRydWUgLy8gU2VlICM1OTAsIGRvbid0IHJlY3Vyc2UgaW50byBub24tZW51bWVyYWJsZSBvZiBub24gZHJhZnRlZCBvYmplY3RzXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH0gLy8gTmV2ZXIgZmluYWxpemUgZHJhZnRzIG93bmVkIGJ5IGFub3RoZXIgc2NvcGUuXHJcblxyXG5cclxuICBpZiAoc3RhdGUuc2NvcGVfICE9PSByb290U2NvcGUpIHJldHVybiB2YWx1ZTsgLy8gVW5tb2RpZmllZCBkcmFmdCwgcmV0dXJuIHRoZSAoZnJvemVuKSBvcmlnaW5hbFxyXG5cclxuICBpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xyXG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBzdGF0ZS5iYXNlXywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gc3RhdGUuYmFzZV87XHJcbiAgfSAvLyBOb3QgZmluYWxpemVkIHlldCwgbGV0J3MgZG8gdGhhdCBub3dcclxuXHJcblxyXG4gIGlmICghc3RhdGUuZmluYWxpemVkXykge1xyXG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XHJcbiAgICBzdGF0ZS5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS07XHJcbiAgICB2YXIgcmVzdWx0ID0gLy8gRm9yIEVTNSwgY3JlYXRlIGEgZ29vZCBjb3B5IGZyb20gdGhlIGRyYWZ0IGZpcnN0LCB3aXRoIGFkZGVkIGtleXMgYW5kIHdpdGhvdXQgZGVsZXRlZCBrZXlzLlxyXG4gICAgc3RhdGUudHlwZV8gPT09IDRcclxuICAgIC8qIEVTNU9iamVjdCAqL1xyXG4gICAgfHwgc3RhdGUudHlwZV8gPT09IDVcclxuICAgIC8qIEVTNUFycmF5ICovXHJcbiAgICA/IHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuZHJhZnRfKSA6IHN0YXRlLmNvcHlfOyAvLyBGaW5hbGl6ZSBhbGwgY2hpbGRyZW4gb2YgdGhlIGNvcHlcclxuICAgIC8vIEZvciBzZXRzIHdlIGNsb25lIGJlZm9yZSBpdGVyYXRpbmcsIG90aGVyd2lzZSB3ZSBjYW4gZ2V0IGluIGVuZGxlc3MgbG9vcCBkdWUgdG8gbW9kaWZ5aW5nIGR1cmluZyBpdGVyYXRpb24sIHNlZSAjNjI4XHJcbiAgICAvLyBUbyBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXIgaW4gYWxsIGNhc2VzIHdlIHRoZW4gY2xlYXIgdGhlIHNldFxyXG4gICAgLy8gQW5kIHdlIGxldCBmaW5hbGl6ZVByb3BlcnR5IGtub3cgaXQgbmVlZHMgdG8gcmUtYWRkIG5vbi1kcmFmdCBjaGlsZHJlbiBiYWNrIHRvIHRoZSB0YXJnZXRcclxuXHJcbiAgICB2YXIgcmVzdWx0RWFjaCA9IHJlc3VsdDtcclxuICAgIHZhciBpc1NldCA9IGZhbHNlO1xyXG5cclxuICAgIGlmIChzdGF0ZS50eXBlXyA9PT0gM1xyXG4gICAgLyogU2V0ICovXHJcbiAgICApIHtcclxuICAgICAgICByZXN1bHRFYWNoID0gbmV3IFNldChyZXN1bHQpO1xyXG4gICAgICAgIHJlc3VsdC5jbGVhcigpO1xyXG4gICAgICAgIGlzU2V0ID0gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgIGVhY2gocmVzdWx0RWFjaCwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCByZXN1bHQsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCwgaXNTZXQpO1xyXG4gICAgfSk7IC8vIGV2ZXJ5dGhpbmcgaW5zaWRlIGlzIGZyb3plbiwgd2UgY2FuIGZyZWV6ZSBoZXJlXHJcblxyXG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCByZXN1bHQsIGZhbHNlKTsgLy8gZmlyc3QgdGltZSBmaW5hbGl6aW5nLCBsZXQncyBjcmVhdGUgdGhvc2UgcGF0Y2hlc1xyXG5cclxuICAgIGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xyXG4gICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUGF0Y2hlc18oc3RhdGUsIHBhdGgsIHJvb3RTY29wZS5wYXRjaGVzXywgcm9vdFNjb3BlLmludmVyc2VQYXRjaGVzXyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGUuY29weV87XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBwYXJlbnRTdGF0ZSwgdGFyZ2V0T2JqZWN0LCBwcm9wLCBjaGlsZFZhbHVlLCByb290UGF0aCwgdGFyZ2V0SXNTZXQpIHtcclxuICBpZiAoIGNoaWxkVmFsdWUgPT09IHRhcmdldE9iamVjdCkgZGllKDUpO1xyXG5cclxuICBpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xyXG4gICAgdmFyIHBhdGggPSByb290UGF0aCAmJiBwYXJlbnRTdGF0ZSAmJiBwYXJlbnRTdGF0ZS50eXBlXyAhPT0gM1xyXG4gICAgLyogU2V0ICovXHJcbiAgICAmJiAvLyBTZXQgb2JqZWN0cyBhcmUgYXRvbWljIHNpbmNlIHRoZXkgaGF2ZSBubyBrZXlzLlxyXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApIC8vIFNraXAgZGVlcCBwYXRjaGVzIGZvciBhc3NpZ25lZCBrZXlzLlxyXG4gICAgPyByb290UGF0aC5jb25jYXQocHJvcCkgOiB1bmRlZmluZWQ7IC8vIERyYWZ0cyBvd25lZCBieSBgc2NvcGVgIGFyZSBmaW5hbGl6ZWQgaGVyZS5cclxuXHJcbiAgICB2YXIgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKTtcclxuICAgIHNldCh0YXJnZXRPYmplY3QsIHByb3AsIHJlcyk7IC8vIERyYWZ0cyBmcm9tIGFub3RoZXIgc2NvcGUgbXVzdCBwcmV2ZW50ZWQgdG8gYmUgZnJvemVuXHJcbiAgICAvLyBpZiB3ZSBnb3QgYSBkcmFmdCBiYWNrIGZyb20gZmluYWxpemUsIHdlJ3JlIGluIGEgbmVzdGVkIHByb2R1Y2UgYW5kIHNob3VsZG4ndCBmcmVlemVcclxuXHJcbiAgICBpZiAoaXNEcmFmdChyZXMpKSB7XHJcbiAgICAgIHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHJldHVybjtcclxuICB9IGVsc2UgaWYgKHRhcmdldElzU2V0KSB7XHJcbiAgICB0YXJnZXRPYmplY3QuYWRkKGNoaWxkVmFsdWUpO1xyXG4gIH0gLy8gU2VhcmNoIG5ldyBvYmplY3RzIGZvciB1bmZpbmFsaXplZCBkcmFmdHMuIEZyb3plbiBvYmplY3RzIHNob3VsZCBuZXZlciBjb250YWluIGRyYWZ0cy5cclxuXHJcblxyXG4gIGlmIChpc0RyYWZ0YWJsZShjaGlsZFZhbHVlKSAmJiAhaXNGcm96ZW4oY2hpbGRWYWx1ZSkpIHtcclxuICAgIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xyXG4gICAgICAvLyBvcHRpbWl6YXRpb246IGlmIGFuIG9iamVjdCBpcyBub3QgYSBkcmFmdCwgYW5kIHdlIGRvbid0IGhhdmUgdG9cclxuICAgICAgLy8gZGVlcGZyZWV6ZSBldmVyeXRoaW5nLCBhbmQgd2UgYXJlIHN1cmUgdGhhdCBubyBkcmFmdHMgYXJlIGxlZnQgaW4gdGhlIHJlbWFpbmluZyBvYmplY3RcclxuICAgICAgLy8gY2F1c2Ugd2Ugc2F3IGFuZCBmaW5hbGl6ZWQgYWxsIGRyYWZ0cyBhbHJlYWR5OyB3ZSBjYW4gc3RvcCB2aXNpdGluZyB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cclxuICAgICAgLy8gVGhpcyBiZW5lZml0cyBlc3BlY2lhbGx5IGFkZGluZyBsYXJnZSBkYXRhIHRyZWUncyB3aXRob3V0IGZ1cnRoZXIgcHJvY2Vzc2luZy5cclxuICAgICAgLy8gU2VlIGFkZC1kYXRhLmpzIHBlcmYgdGVzdFxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTsgLy8gaW1tZXIgZGVlcCBmcmVlemVzIHBsYWluIG9iamVjdHMsIHNvIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBzdGF0ZSwgd2UgZnJlZXplIGFzIHdlbGxcclxuXHJcbiAgICBpZiAoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50XykgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlLCB2YWx1ZSwgZGVlcCkge1xyXG4gIGlmIChkZWVwID09PSB2b2lkIDApIHtcclxuICAgIGRlZXAgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8vIHdlIG5ldmVyIGZyZWV6ZSBmb3IgYSBub24tcm9vdCBzY29wZTsgYXMgaXQgd291bGQgcHJldmVudCBwcnVuaW5nIGZvciBkcmFmdHMgaW5zaWRlIHdyYXBwaW5nIG9iamVjdHNcclxuICBpZiAoIXNjb3BlLnBhcmVudF8gJiYgc2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHNjb3BlLmNhbkF1dG9GcmVlemVfKSB7XHJcbiAgICBmcmVlemUodmFsdWUsIGRlZXApO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgZHJhZnQgb2YgdGhlIGBiYXNlYCBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIHBhcmVudCBkcmFmdC1zdGF0ZSAodXNlZCBpbnRlcm5hbGx5KS5cclxuICovXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVQcm94eVByb3h5KGJhc2UsIHBhcmVudCkge1xyXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcclxuICB2YXIgc3RhdGUgPSB7XHJcbiAgICB0eXBlXzogaXNBcnJheSA/IDFcclxuICAgIC8qIFByb3h5QXJyYXkgKi9cclxuICAgIDogMFxyXG4gICAgLyogUHJveHlPYmplY3QgKi9cclxuICAgICxcclxuICAgIC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cclxuICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxyXG4gICAgLy8gVHJ1ZSBmb3IgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNoYW5nZXMuXHJcbiAgICBtb2RpZmllZF86IGZhbHNlLFxyXG4gICAgLy8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxyXG4gICAgZmluYWxpemVkXzogZmFsc2UsXHJcbiAgICAvLyBUcmFjayB3aGljaCBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBhc3NpZ25lZCAodHJ1ZSkgb3IgZGVsZXRlZCAoZmFsc2UpLlxyXG4gICAgYXNzaWduZWRfOiB7fSxcclxuICAgIC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXHJcbiAgICBwYXJlbnRfOiBwYXJlbnQsXHJcbiAgICAvLyBUaGUgYmFzZSBzdGF0ZS5cclxuICAgIGJhc2VfOiBiYXNlLFxyXG4gICAgLy8gVGhlIGJhc2UgcHJveHkuXHJcbiAgICBkcmFmdF86IG51bGwsXHJcbiAgICAvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxyXG4gICAgY29weV86IG51bGwsXHJcbiAgICAvLyBDYWxsZWQgYnkgdGhlIGBwcm9kdWNlYCBmdW5jdGlvbi5cclxuICAgIHJldm9rZV86IG51bGwsXHJcbiAgICBpc01hbnVhbF86IGZhbHNlXHJcbiAgfTsgLy8gdGhlIHRyYXBzIG11c3QgdGFyZ2V0IHNvbWV0aGluZywgYSBiaXQgbGlrZSB0aGUgJ3JlYWwnIGJhc2UuXHJcbiAgLy8gYnV0IGFsc28sIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBkZXRlcm1pbmUgZnJvbSB0aGUgdGFyZ2V0IHdoYXQgdGhlIHJlbGV2YW50IHN0YXRlIGlzXHJcbiAgLy8gKHRvIGF2b2lkIGNyZWF0aW5nIHRyYXBzIHBlciBpbnN0YW5jZSB0byBjYXB0dXJlIHRoZSBzdGF0ZSBpbiBjbG9zdXJlLFxyXG4gIC8vIGFuZCB0byBhdm9pZCBjcmVhdGluZyB3ZWlyZCBoaWRkZW4gcHJvcGVydGllcyBhcyB3ZWxsKVxyXG4gIC8vIFNvIHRoZSB0cmljayBpcyB0byB1c2UgJ3N0YXRlJyBhcyB0aGUgYWN0dWFsICd0YXJnZXQnISAoYW5kIG1ha2Ugc3VyZSB3ZSBpbnRlcmNlcHQgZXZlcnl0aGluZylcclxuICAvLyBOb3RlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXksIHdlIHB1dCB0aGUgc3RhdGUgaW4gYW4gYXJyYXkgdG8gaGF2ZSBiZXR0ZXIgUmVmbGVjdCBkZWZhdWx0cyBvb3RiXHJcblxyXG4gIHZhciB0YXJnZXQgPSBzdGF0ZTtcclxuICB2YXIgdHJhcHMgPSBvYmplY3RUcmFwcztcclxuXHJcbiAgaWYgKGlzQXJyYXkpIHtcclxuICAgIHRhcmdldCA9IFtzdGF0ZV07XHJcbiAgICB0cmFwcyA9IGFycmF5VHJhcHM7XHJcbiAgfVxyXG5cclxuICB2YXIgX1Byb3h5JHJldm9jYWJsZSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKSxcclxuICAgICAgcmV2b2tlID0gX1Byb3h5JHJldm9jYWJsZS5yZXZva2UsXHJcbiAgICAgIHByb3h5ID0gX1Byb3h5JHJldm9jYWJsZS5wcm94eTtcclxuXHJcbiAgc3RhdGUuZHJhZnRfID0gcHJveHk7XHJcbiAgc3RhdGUucmV2b2tlXyA9IHJldm9rZTtcclxuICByZXR1cm4gcHJveHk7XHJcbn1cclxuLyoqXHJcbiAqIE9iamVjdCBkcmFmdHNcclxuICovXHJcblxyXG52YXIgb2JqZWN0VHJhcHMgPSB7XHJcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoc3RhdGUsIHByb3ApIHtcclxuICAgIGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgcmV0dXJuIHN0YXRlO1xyXG4gICAgdmFyIHNvdXJjZSA9IGxhdGVzdChzdGF0ZSk7XHJcblxyXG4gICAgaWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xyXG4gICAgICAvLyBub24tZXhpc3Rpbmcgb3Igbm9uLW93biBwcm9wZXJ0eS4uLlxyXG4gICAgICByZXR1cm4gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGUsIHNvdXJjZSwgcHJvcCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BdO1xyXG5cclxuICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfSAvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gbW9kaWZpZWQgc3RhdGUuXHJcbiAgICAvLyBBc3NpZ25lZCB2YWx1ZXMgYXJlIG5ldmVyIGRyYWZ0ZWQuIFRoaXMgY2F0Y2hlcyBhbnkgZHJhZnRzIHdlIGNyZWF0ZWQsIHRvby5cclxuXHJcblxyXG4gICAgaWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xyXG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5X1twcm9wXSA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH0sXHJcbiAgaGFzOiBmdW5jdGlvbiBoYXMoc3RhdGUsIHByb3ApIHtcclxuICAgIHJldHVybiBwcm9wIGluIGxhdGVzdChzdGF0ZSk7XHJcbiAgfSxcclxuICBvd25LZXlzOiBmdW5jdGlvbiBvd25LZXlzKHN0YXRlKSB7XHJcbiAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpO1xyXG4gIH0sXHJcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUsIHByb3BcclxuICAvKiBzdHJpY3RseSBub3QsIGJ1dCBoZWxwcyBUUyAqL1xyXG4gICwgdmFsdWUpIHtcclxuICAgIHZhciBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcclxuXHJcbiAgICBpZiAoZGVzYyA9PT0gbnVsbCB8fCBkZXNjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXNjLnNldCkge1xyXG4gICAgICAvLyBzcGVjaWFsIGNhc2U6IGlmIHRoaXMgd3JpdGUgaXMgY2FwdHVyZWQgYnkgYSBzZXR0ZXIsIHdlIGhhdmVcclxuICAgICAgLy8gdG8gdHJpZ2dlciBpdCB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcclxuICAgICAgZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcclxuICAgICAgLy8gdGhlIGxhc3QgY2hlY2sgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggc2V0dGluZyBhIG5vbi1leGlzdGluZyB0byB1bmRlZmluZWQgKHdoaWNoIGlzIGEgY2hhbmdlKVxyXG4gICAgICAvLyBmcm9tIHNldHRpbmcgYW4gZXhpc3RpbmcgcHJvcGVydHkgd2l0aCB2YWx1ZSB1bmRlZmluZWQgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBub3QgYSBjaGFuZ2UpXHJcbiAgICAgIHZhciBjdXJyZW50ID0gcGVlayhsYXRlc3Qoc3RhdGUpLCBwcm9wKTsgLy8gc3BlY2lhbCBjYXNlLCBpZiB3ZSBhc3NpZ25pbmcgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIGEgZHJhZnQsIHdlIGNhbiBpZ25vcmUgdGhlIGFzc2lnbm1lbnRcclxuXHJcbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRbRFJBRlRfU1RBVEVdO1xyXG5cclxuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzKHZhbHVlLCBjdXJyZW50KSAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcclxuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZS5jb3B5X1twcm9wXSA9PT0gdmFsdWUgJiYgKCAvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xyXG4gICAgdmFsdWUgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmNvcHlfKSB8fCAvLyBzcGVjaWFsIGNhc2U6IE5hTlxyXG4gICAgTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV9bcHJvcF0pKSByZXR1cm4gdHJ1ZTsgLy8gQHRzLWlnbm9yZVxyXG5cclxuICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XHJcbiAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3ApIHtcclxuICAgIC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXHJcbiAgICBpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XHJcbiAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xyXG4gICAgICBwcmVwYXJlQ29weShzdGF0ZSk7XHJcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGlmIGFuIG9yaWdpbmFsbHkgbm90IGFzc2lnbmVkIHByb3BlcnR5IHdhcyBkZWxldGVkXHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5hc3NpZ25lZF9bcHJvcF07XHJcbiAgICB9IC8vIEB0cy1pZ25vcmVcclxuXHJcblxyXG4gICAgaWYgKHN0YXRlLmNvcHlfKSBkZWxldGUgc3RhdGUuY29weV9bcHJvcF07XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9LFxyXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXHJcbiAgLy8gdGhlIHNhbWUgZ3VhcmFudGVlIGluIEVTNSBtb2RlLlxyXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XHJcbiAgICB2YXIgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xyXG4gICAgdmFyIGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcCk7XHJcbiAgICBpZiAoIWRlc2MpIHJldHVybiBkZXNjO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgIGNvbmZpZ3VyYWJsZTogc3RhdGUudHlwZV8gIT09IDFcclxuICAgICAgLyogUHJveHlBcnJheSAqL1xyXG4gICAgICB8fCBwcm9wICE9PSBcImxlbmd0aFwiLFxyXG4gICAgICBlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXHJcbiAgICAgIHZhbHVlOiBvd25lcltwcm9wXVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGRlZmluZVByb3BlcnR5OiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSgpIHtcclxuICAgIGRpZSgxMSk7XHJcbiAgfSxcclxuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcclxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pO1xyXG4gIH0sXHJcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKCkge1xyXG4gICAgZGllKDEyKTtcclxuICB9XHJcbn07XHJcbi8qKlxyXG4gKiBBcnJheSBkcmFmdHNcclxuICovXHJcblxyXG52YXIgYXJyYXlUcmFwcyA9IHt9O1xyXG5lYWNoKG9iamVjdFRyYXBzLCBmdW5jdGlvbiAoa2V5LCBmbikge1xyXG4gIC8vIEB0cy1pZ25vcmVcclxuICBhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF07XHJcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG59KTtcclxuXHJcbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbiAoc3RhdGUsIHByb3ApIHtcclxuICBpZiAoIGlzTmFOKHBhcnNlSW50KHByb3ApKSkgZGllKDEzKTsgLy8gQHRzLWlnbm9yZVxyXG5cclxuICByZXR1cm4gYXJyYXlUcmFwcy5zZXQuY2FsbCh0aGlzLCBzdGF0ZSwgcHJvcCwgdW5kZWZpbmVkKTtcclxufTtcclxuXHJcbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24gKHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xyXG4gIGlmICggcHJvcCAhPT0gXCJsZW5ndGhcIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpIGRpZSgxNCk7XHJcbiAgcmV0dXJuIG9iamVjdFRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pO1xyXG59OyAvLyBBY2Nlc3MgYSBwcm9wZXJ0eSB3aXRob3V0IGNyZWF0aW5nIGFuIEltbWVyIGRyYWZ0LlxyXG5cclxuXHJcbmZ1bmN0aW9uIHBlZWsoZHJhZnQsIHByb3ApIHtcclxuICB2YXIgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XHJcbiAgdmFyIHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IGRyYWZ0O1xyXG4gIHJldHVybiBzb3VyY2VbcHJvcF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApIHtcclxuICB2YXIgX2Rlc2MkZ2V0O1xyXG5cclxuICB2YXIgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKTtcclxuICByZXR1cm4gZGVzYyA/IFwidmFsdWVcIiBpbiBkZXNjID8gZGVzYy52YWx1ZSA6IC8vIFRoaXMgaXMgYSB2ZXJ5IHNwZWNpYWwgY2FzZSwgaWYgdGhlIHByb3AgaXMgYSBnZXR0ZXIgZGVmaW5lZCBieSB0aGVcclxuICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcclxuICAoX2Rlc2MkZ2V0ID0gZGVzYy5nZXQpID09PSBudWxsIHx8IF9kZXNjJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Rlc2MkZ2V0LmNhbGwoc3RhdGUuZHJhZnRfKSA6IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApIHtcclxuICAvLyAnaW4nIGNoZWNrcyBwcm90byFcclxuICBpZiAoIShwcm9wIGluIHNvdXJjZSkpIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSk7XHJcblxyXG4gIHdoaWxlIChwcm90bykge1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKTtcclxuICAgIGlmIChkZXNjKSByZXR1cm4gZGVzYztcclxuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlKSB7XHJcbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcclxuICAgIHN0YXRlLm1vZGlmaWVkXyA9IHRydWU7XHJcblxyXG4gICAgaWYgKHN0YXRlLnBhcmVudF8pIHtcclxuICAgICAgbWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xyk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XHJcbiAgaWYgKCFzdGF0ZS5jb3B5Xykge1xyXG4gICAgc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShzdGF0ZS5iYXNlXyk7XHJcbiAgfVxyXG59XHJcblxyXG52YXIgSW1tZXIgPVxyXG4vKiNfX1BVUkVfXyovXHJcbmZ1bmN0aW9uICgpIHtcclxuICBmdW5jdGlvbiBJbW1lcihjb25maWcpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy51c2VQcm94aWVzXyA9IGhhc1Byb3hpZXM7XHJcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdHJ1ZTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXHJcbiAgICAgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcclxuICAgICAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gICAgICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICAgICAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAgICAgKiBjb25zaWRlcmVkIHVuY29weWFibGUuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVjaXBlIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXHJcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcclxuICAgICAqL1xyXG5cclxuICAgIHRoaXMucHJvZHVjZSA9IGZ1bmN0aW9uIChiYXNlLCByZWNpcGUsIHBhdGNoTGlzdGVuZXIpIHtcclxuICAgICAgLy8gY3VycmllZCBpbnZvY2F0aW9uXHJcbiAgICAgIGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHZhciBkZWZhdWx0QmFzZSA9IHJlY2lwZTtcclxuICAgICAgICByZWNpcGUgPSBiYXNlO1xyXG4gICAgICAgIHZhciBzZWxmID0gX3RoaXM7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRQcm9kdWNlKGJhc2UpIHtcclxuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xyXG5cclxuICAgICAgICAgIGlmIChiYXNlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYmFzZSA9IGRlZmF1bHRCYXNlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHNlbGYucHJvZHVjZShiYXNlLCBmdW5jdGlvbiAoZHJhZnQpIHtcclxuICAgICAgICAgICAgdmFyIF9yZWNpcGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKF9yZWNpcGUgPSByZWNpcGUpLmNhbGwuYXBwbHkoX3JlY2lwZSwgW190aGlzMiwgZHJhZnRdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgICB9KTsgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikgZGllKDYpO1xyXG4gICAgICBpZiAocGF0Y2hMaXN0ZW5lciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwYXRjaExpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg3KTtcclxuICAgICAgdmFyIHJlc3VsdDsgLy8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXHJcblxyXG4gICAgICBpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcclxuICAgICAgICB2YXIgc2NvcGUgPSBlbnRlclNjb3BlKF90aGlzKTtcclxuICAgICAgICB2YXIgcHJveHkgPSBjcmVhdGVQcm94eShfdGhpcywgYmFzZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICB2YXIgaGFzRXJyb3IgPSB0cnVlO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gcmVjaXBlKHByb3h5KTtcclxuICAgICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIC8vIGZpbmFsbHkgaW5zdGVhZCBvZiBjYXRjaCArIHJldGhyb3cgYmV0dGVyIHByZXNlcnZlcyBvcmlnaW5hbCBzdGFja1xyXG4gICAgICAgICAgaWYgKGhhc0Vycm9yKSByZXZva2VTY29wZShzY29wZSk7ZWxzZSBsZWF2ZVNjb3BlKHNjb3BlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgICAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpO1xyXG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldm9rZVNjb3BlKHNjb3BlKTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcclxuICAgICAgICByZXR1cm4gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKTtcclxuICAgICAgfSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShiYXNlKTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IGJhc2U7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gTk9USElORykgcmVzdWx0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChfdGhpcy5hdXRvRnJlZXplXykgZnJlZXplKHJlc3VsdCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGlmIChwYXRjaExpc3RlbmVyKSB7XHJcbiAgICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgICAgdmFyIGlwID0gW107XHJcbiAgICAgICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlLCByZXN1bHQsIHAsIGlwKTtcclxuICAgICAgICAgIHBhdGNoTGlzdGVuZXIocCwgaXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSBlbHNlIGRpZSgyMSwgYmFzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gZnVuY3Rpb24gKGJhc2UsIHJlY2lwZSkge1xyXG4gICAgICAvLyBjdXJyaWVkIGludm9jYXRpb25cclxuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xyXG4gICAgICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIGZ1bmN0aW9uIChkcmFmdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYmFzZS5hcHBseSh2b2lkIDAsIFtkcmFmdF0uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcztcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5wcm9kdWNlKGJhc2UsIHJlY2lwZSwgZnVuY3Rpb24gKHAsIGlwKSB7XHJcbiAgICAgICAgcGF0Y2hlcyA9IHA7XHJcbiAgICAgICAgaW52ZXJzZVBhdGNoZXMgPSBpcDtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAobmV4dFN0YXRlKSB7XHJcbiAgICAgICAgICByZXR1cm4gW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodHlwZW9mIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudXNlUHJveGllcykgPT09IFwiYm9vbGVhblwiKSB0aGlzLnNldFVzZVByb3hpZXMoY29uZmlnLnVzZVByb3hpZXMpO1xyXG4gICAgaWYgKHR5cGVvZiAoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9GcmVlemUpID09PSBcImJvb2xlYW5cIikgdGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZy5hdXRvRnJlZXplKTtcclxuICB9XHJcblxyXG4gIHZhciBfcHJvdG8gPSBJbW1lci5wcm90b3R5cGU7XHJcblxyXG4gIF9wcm90by5jcmVhdGVEcmFmdCA9IGZ1bmN0aW9uIGNyZWF0ZURyYWZ0KGJhc2UpIHtcclxuICAgIGlmICghaXNEcmFmdGFibGUoYmFzZSkpIGRpZSg4KTtcclxuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSBiYXNlID0gY3VycmVudChiYXNlKTtcclxuICAgIHZhciBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XHJcbiAgICB2YXIgcHJveHkgPSBjcmVhdGVQcm94eSh0aGlzLCBiYXNlLCB1bmRlZmluZWQpO1xyXG4gICAgcHJveHlbRFJBRlRfU1RBVEVdLmlzTWFudWFsXyA9IHRydWU7XHJcbiAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcclxuICAgIHJldHVybiBwcm94eTtcclxuICB9O1xyXG5cclxuICBfcHJvdG8uZmluaXNoRHJhZnQgPSBmdW5jdGlvbiBmaW5pc2hEcmFmdChkcmFmdCwgcGF0Y2hMaXN0ZW5lcikge1xyXG4gICAgdmFyIHN0YXRlID0gZHJhZnQgJiYgZHJhZnRbRFJBRlRfU1RBVEVdO1xyXG5cclxuICAgIHtcclxuICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuaXNNYW51YWxfKSBkaWUoOSk7XHJcbiAgICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfKSBkaWUoMTApO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBzY29wZSA9IHN0YXRlLnNjb3BlXztcclxuICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcclxuICAgIHJldHVybiBwcm9jZXNzUmVzdWx0KHVuZGVmaW5lZCwgc2NvcGUpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBlbmFibGVkLlxyXG4gICAqL1xyXG4gIDtcclxuXHJcbiAgX3Byb3RvLnNldEF1dG9GcmVlemUgPSBmdW5jdGlvbiBzZXRBdXRvRnJlZXplKHZhbHVlKSB7XHJcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdmFsdWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIEVTMjAxNSBgUHJveHlgIGNsYXNzIHdoZW4gY3JlYXRpbmcgZHJhZnRzLCB3aGljaCBpc1xyXG4gICAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cclxuICAgKlxyXG4gICAqIEJ5IGRlZmF1bHQsIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVzZWQsIHNvIGNhbGxpbmcgdGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5LlxyXG4gICAqL1xyXG4gIDtcclxuXHJcbiAgX3Byb3RvLnNldFVzZVByb3hpZXMgPSBmdW5jdGlvbiBzZXRVc2VQcm94aWVzKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgJiYgIWhhc1Byb3hpZXMpIHtcclxuICAgICAgZGllKDIwKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnVzZVByb3hpZXNfID0gdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgX3Byb3RvLmFwcGx5UGF0Y2hlcyA9IGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyhiYXNlLCBwYXRjaGVzKSB7XHJcbiAgICAvLyBJZiBhIHBhdGNoIHJlcGxhY2VzIHRoZSBlbnRpcmUgc3RhdGUsIHRha2UgdGhhdCByZXBsYWNlbWVudCBhcyBiYXNlXHJcbiAgICAvLyBiZWZvcmUgYXBwbHlpbmcgcGF0Y2hlc1xyXG4gICAgdmFyIGk7XHJcblxyXG4gICAgZm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICB2YXIgcGF0Y2ggPSBwYXRjaGVzW2ldO1xyXG5cclxuICAgICAgaWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwICYmIHBhdGNoLm9wID09PSBcInJlcGxhY2VcIikge1xyXG4gICAgICAgIGJhc2UgPSBwYXRjaC52YWx1ZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfSAvLyBJZiB0aGVyZSB3YXMgYSBwYXRjaCB0aGF0IHJlcGxhY2VkIHRoZSBlbnRpcmUgc3RhdGUsIHN0YXJ0IGZyb20gdGhlXHJcbiAgICAvLyBwYXRjaCBhZnRlciB0aGF0LlxyXG5cclxuXHJcbiAgICBpZiAoaSA+IC0xKSB7XHJcbiAgICAgIHBhdGNoZXMgPSBwYXRjaGVzLnNsaWNlKGkgKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXBwbHlQYXRjaGVzSW1wbCA9IGdldFBsdWdpbihcIlBhdGNoZXNcIikuYXBwbHlQYXRjaGVzXztcclxuXHJcbiAgICBpZiAoaXNEcmFmdChiYXNlKSkge1xyXG4gICAgICAvLyBOLkI6IG5ldmVyIGhpdHMgaWYgc29tZSBwYXRjaCBhIHJlcGxhY2VtZW50LCBwYXRjaGVzIGFyZSBuZXZlciBkcmFmdHNcclxuICAgICAgcmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcyk7XHJcbiAgICB9IC8vIE90aGVyd2lzZSwgcHJvZHVjZSBhIGNvcHkgb2YgdGhlIGJhc2Ugc3RhdGUuXHJcblxyXG5cclxuICAgIHJldHVybiB0aGlzLnByb2R1Y2UoYmFzZSwgZnVuY3Rpb24gKGRyYWZ0KSB7XHJcbiAgICAgIHJldHVybiBhcHBseVBhdGNoZXNJbXBsKGRyYWZ0LCBwYXRjaGVzKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBJbW1lcjtcclxufSgpO1xyXG5mdW5jdGlvbiBjcmVhdGVQcm94eShpbW1lciwgdmFsdWUsIHBhcmVudCkge1xyXG4gIC8vIHByZWNvbmRpdGlvbjogY3JlYXRlUHJveHkgc2hvdWxkIGJlIGd1YXJkZWQgYnkgaXNEcmFmdGFibGUsIHNvIHdlIGtub3cgd2UgY2FuIHNhZmVseSBkcmFmdFxyXG4gIHZhciBkcmFmdCA9IGlzTWFwKHZhbHVlKSA/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eU1hcF8odmFsdWUsIHBhcmVudCkgOiBpc1NldCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpIDogaW1tZXIudXNlUHJveGllc18gPyBjcmVhdGVQcm94eVByb3h5KHZhbHVlLCBwYXJlbnQpIDogZ2V0UGx1Z2luKFwiRVM1XCIpLmNyZWF0ZUVTNVByb3h5Xyh2YWx1ZSwgcGFyZW50KTtcclxuICB2YXIgc2NvcGUgPSBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCk7XHJcbiAgc2NvcGUuZHJhZnRzXy5wdXNoKGRyYWZ0KTtcclxuICByZXR1cm4gZHJhZnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGN1cnJlbnQodmFsdWUpIHtcclxuICBpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjIsIHZhbHVlKTtcclxuICByZXR1cm4gY3VycmVudEltcGwodmFsdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjdXJyZW50SW1wbCh2YWx1ZSkge1xyXG4gIGlmICghaXNEcmFmdGFibGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XHJcbiAgdmFyIHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xyXG4gIHZhciBjb3B5O1xyXG4gIHZhciBhcmNoVHlwZSA9IGdldEFyY2h0eXBlKHZhbHVlKTtcclxuXHJcbiAgaWYgKHN0YXRlKSB7XHJcbiAgICBpZiAoIXN0YXRlLm1vZGlmaWVkXyAmJiAoc3RhdGUudHlwZV8gPCA0IHx8ICFnZXRQbHVnaW4oXCJFUzVcIikuaGFzQ2hhbmdlc18oc3RhdGUpKSkgcmV0dXJuIHN0YXRlLmJhc2VfOyAvLyBPcHRpbWl6YXRpb246IGF2b2lkIGdlbmVyYXRpbmcgbmV3IGRyYWZ0cyBkdXJpbmcgY29weWluZ1xyXG5cclxuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xyXG4gICAgY29weSA9IGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKTtcclxuICAgIHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29weSA9IGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKTtcclxuICB9XHJcblxyXG4gIGVhY2goY29weSwgZnVuY3Rpb24gKGtleSwgY2hpbGRWYWx1ZSkge1xyXG4gICAgaWYgKHN0YXRlICYmIGdldChzdGF0ZS5iYXNlXywga2V5KSA9PT0gY2hpbGRWYWx1ZSkgcmV0dXJuOyAvLyBubyBuZWVkIHRvIGNvcHkgb3Igc2VhcmNoIGluIHNvbWV0aGluZyB0aGF0IGRpZG4ndCBjaGFuZ2VcclxuXHJcbiAgICBzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSk7XHJcbiAgfSk7IC8vIEluIHRoZSBmdXR1cmUsIHdlIG1pZ2h0IGNvbnNpZGVyIGZyZWV6aW5nIGhlcmUsIGJhc2VkIG9uIHRoZSBjdXJyZW50IHNldHRpbmdzXHJcblxyXG4gIHJldHVybiBhcmNoVHlwZSA9PT0gM1xyXG4gIC8qIFNldCAqL1xyXG4gID8gbmV3IFNldChjb3B5KSA6IGNvcHk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKSB7XHJcbiAgLy8gY3JlYXRlcyBhIHNoYWxsb3cgY29weSwgZXZlbiBpZiBpdCBpcyBhIG1hcCBvciBzZXRcclxuICBzd2l0Y2ggKGFyY2hUeXBlKSB7XHJcbiAgICBjYXNlIDJcclxuICAgIC8qIE1hcCAqL1xyXG4gICAgOlxyXG4gICAgICByZXR1cm4gbmV3IE1hcCh2YWx1ZSk7XHJcblxyXG4gICAgY2FzZSAzXHJcbiAgICAvKiBTZXQgKi9cclxuICAgIDpcclxuICAgICAgLy8gU2V0IHdpbGwgYmUgY2xvbmVkIGFzIGFycmF5IHRlbXBvcmFyaWx5LCBzbyB0aGF0IHdlIGNhbiByZXBsYWNlIGluZGl2aWR1YWwgaXRlbXNcclxuICAgICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNoYWxsb3dDb3B5KHZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5hYmxlRVM1KCkge1xyXG4gIGZ1bmN0aW9uIHdpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZCkge1xyXG4gICAgaWYgKCFpc1JlcGxhY2VkKSB7XHJcbiAgICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xyXG4gICAgICAgIG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoc2NvcGUuZHJhZnRzX1swXSk7XHJcbiAgICAgIH0gLy8gVGhpcyBpcyBmYXN0ZXIgd2hlbiB3ZSBkb24ndCBjYXJlIGFib3V0IHdoaWNoIGF0dHJpYnV0ZXMgY2hhbmdlZC5cclxuXHJcblxyXG4gICAgICBtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0c18pO1xyXG4gICAgfSAvLyBXaGVuIGEgY2hpbGQgZHJhZnQgaXMgcmV0dXJuZWQsIGxvb2sgZm9yIGNoYW5nZXMuXHJcbiAgICBlbHNlIGlmIChpc0RyYWZ0KHJlc3VsdCkgJiYgcmVzdWx0W0RSQUZUX1NUQVRFXS5zY29wZV8gPT09IHNjb3BlKSB7XHJcbiAgICAgICAgbWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKTtcclxuICAgICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlRVM1RHJhZnQoaXNBcnJheSwgYmFzZSkge1xyXG4gICAgaWYgKGlzQXJyYXkpIHtcclxuICAgICAgdmFyIGRyYWZ0ID0gbmV3IEFycmF5KGJhc2UubGVuZ3RoKTtcclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkcmFmdCwgXCJcIiArIGksIHByb3h5UHJvcGVydHkoaSwgdHJ1ZSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZHJhZnQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIgX2Rlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKTtcclxuXHJcbiAgICAgIGRlbGV0ZSBfZGVzY3JpcHRvcnNbRFJBRlRfU1RBVEVdO1xyXG4gICAgICB2YXIga2V5cyA9IG93bktleXMoX2Rlc2NyaXB0b3JzKTtcclxuXHJcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBrZXlzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW19pXTtcclxuICAgICAgICBfZGVzY3JpcHRvcnNba2V5XSA9IHByb3h5UHJvcGVydHkoa2V5LCBpc0FycmF5IHx8ICEhX2Rlc2NyaXB0b3JzW2tleV0uZW51bWVyYWJsZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgX2Rlc2NyaXB0b3JzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNyZWF0ZUVTNVByb3h5XyhiYXNlLCBwYXJlbnQpIHtcclxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKTtcclxuICAgIHZhciBkcmFmdCA9IGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpO1xyXG4gICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICB0eXBlXzogaXNBcnJheSA/IDVcclxuICAgICAgLyogRVM1QXJyYXkgKi9cclxuICAgICAgOiA0XHJcbiAgICAgIC8qIEVTNU9iamVjdCAqL1xyXG4gICAgICAsXHJcbiAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxyXG4gICAgICBtb2RpZmllZF86IGZhbHNlLFxyXG4gICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcclxuICAgICAgYXNzaWduZWRfOiB7fSxcclxuICAgICAgcGFyZW50XzogcGFyZW50LFxyXG4gICAgICAvLyBiYXNlIGlzIHRoZSBvYmplY3Qgd2UgYXJlIGRyYWZ0aW5nXHJcbiAgICAgIGJhc2VfOiBiYXNlLFxyXG4gICAgICAvLyBkcmFmdCBpcyB0aGUgZHJhZnQgb2JqZWN0IGl0c2VsZiwgdGhhdCB0cmFwcyBhbGwgcmVhZHMgYW5kIHJlYWRzIGZyb20gZWl0aGVyIHRoZSBiYXNlIChpZiB1bm1vZGlmaWVkKSBvciBjb3B5IChpZiBtb2RpZmllZClcclxuICAgICAgZHJhZnRfOiBkcmFmdCxcclxuICAgICAgY29weV86IG51bGwsXHJcbiAgICAgIHJldm9rZWRfOiBmYWxzZSxcclxuICAgICAgaXNNYW51YWxfOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkcmFmdCwgRFJBRlRfU1RBVEUsIHtcclxuICAgICAgdmFsdWU6IHN0YXRlLFxyXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSA8LSB0aGUgZGVmYXVsdFxyXG4gICAgICB3cml0YWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZHJhZnQ7XHJcbiAgfSAvLyBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBhcmUgcmVjeWNsZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IGNyZWF0ZSBhIGdldCBhbmQgc2V0IGNsb3N1cmUgcGVyIHByb3BlcnR5LFxyXG4gIC8vIGJ1dCBzaGFyZSB0aGVtIGFsbCBpbnN0ZWFkXHJcblxyXG5cclxuICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcclxuXHJcbiAgZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShwcm9wLCBlbnVtZXJhYmxlKSB7XHJcbiAgICB2YXIgZGVzYyA9IGRlc2NyaXB0b3JzW3Byb3BdO1xyXG5cclxuICAgIGlmIChkZXNjKSB7XHJcbiAgICAgIGRlc2MuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkZXNjcmlwdG9yc1twcm9wXSA9IGRlc2MgPSB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XHJcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIEB0cy1pZ25vcmVcclxuXHJcbiAgICAgICAgICByZXR1cm4gb2JqZWN0VHJhcHMuZ2V0KHN0YXRlLCBwcm9wKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIEB0cy1pZ25vcmVcclxuXHJcbiAgICAgICAgICBvYmplY3RUcmFwcy5zZXQoc3RhdGUsIHByb3AsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGRlc2M7XHJcbiAgfSAvLyBUaGlzIGxvb2tzIGV4cGVuc2l2ZSwgYnV0IG9ubHkgcHJveGllcyBhcmUgdmlzaXRlZCwgYW5kIG9ubHkgb2JqZWN0cyB3aXRob3V0IGtub3duIGNoYW5nZXMgYXJlIHNjYW5uZWQuXHJcblxyXG5cclxuICBmdW5jdGlvbiBtYXJrQ2hhbmdlc1N3ZWVwKGRyYWZ0cykge1xyXG4gICAgLy8gVGhlIG5hdHVyYWwgb3JkZXIgb2YgZHJhZnRzIGluIHRoZSBgc2NvcGVgIGFycmF5IGlzIGJhc2VkIG9uIHdoZW4gdGhleVxyXG4gICAgLy8gd2VyZSBhY2Nlc3NlZC4gQnkgcHJvY2Vzc2luZyBkcmFmdHMgaW4gcmV2ZXJzZSBuYXR1cmFsIG9yZGVyLCB3ZSBoYXZlIGFcclxuICAgIC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXHJcbiAgICAvLyBoYXZlIGNoYW5nZWQsIHdlIGNhbiBhdm9pZCBhbnkgdHJhdmVyc2FsIG9mIGl0cyBhbmNlc3RvciBub2Rlcy5cclxuICAgIGZvciAodmFyIGkgPSBkcmFmdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdmFyIHN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXTtcclxuXHJcbiAgICAgIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XHJcbiAgICAgICAgc3dpdGNoIChzdGF0ZS50eXBlXykge1xyXG4gICAgICAgICAgY2FzZSA1XHJcbiAgICAgICAgICAvKiBFUzVBcnJheSAqL1xyXG4gICAgICAgICAgOlxyXG4gICAgICAgICAgICBpZiAoaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSkgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIDRcclxuICAgICAgICAgIC8qIEVTNU9iamVjdCAqL1xyXG4gICAgICAgICAgOlxyXG4gICAgICAgICAgICBpZiAoaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KG9iamVjdCkge1xyXG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIikgcmV0dXJuO1xyXG4gICAgdmFyIHN0YXRlID0gb2JqZWN0W0RSQUZUX1NUQVRFXTtcclxuICAgIGlmICghc3RhdGUpIHJldHVybjtcclxuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxyXG4gICAgICAgIGRyYWZ0XyA9IHN0YXRlLmRyYWZ0XyxcclxuICAgICAgICBhc3NpZ25lZF8gPSBzdGF0ZS5hc3NpZ25lZF8sXHJcbiAgICAgICAgdHlwZV8gPSBzdGF0ZS50eXBlXztcclxuXHJcbiAgICBpZiAodHlwZV8gPT09IDRcclxuICAgIC8qIEVTNU9iamVjdCAqL1xyXG4gICAgKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgYWRkZWQga2V5cy5cclxuICAgICAgICAvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXHJcbiAgICAgICAgLy8gdW5uZWNlc3Nhcnkgd29yay5cclxuICAgICAgICAvLyBhbHNvOiBwcm9iYWJseSB3ZSBjYW4gc3RvcmUgdGhlIGluZm9ybWF0aW9uIHdlIGRldGVjdCBoZXJlLCB0byBzcGVlZCB1cCB0cmVlIGZpbmFsaXphdGlvbiFcclxuICAgICAgICBlYWNoKGRyYWZ0XywgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgaWYgKGtleSA9PT0gRFJBRlRfU1RBVEUpIHJldHVybjsgLy8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cclxuXHJcbiAgICAgICAgICBpZiAoYmFzZV9ba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcclxuICAgICAgICAgICAgYXNzaWduZWRfW2tleV0gPSB0cnVlO1xyXG4gICAgICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhc3NpZ25lZF9ba2V5XSkge1xyXG4gICAgICAgICAgICAvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxyXG4gICAgICAgICAgICBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0X1trZXldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTsgLy8gTG9vayBmb3IgcmVtb3ZlZCBrZXlzLlxyXG5cclxuICAgICAgICBlYWNoKGJhc2VfLCBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxyXG4gICAgICAgICAgaWYgKGRyYWZ0X1trZXldID09PSB1bmRlZmluZWQgJiYgIWhhcyhkcmFmdF8sIGtleSkpIHtcclxuICAgICAgICAgICAgYXNzaWduZWRfW2tleV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVfID09PSA1XHJcbiAgICAvKiBFUzVBcnJheSAqL1xyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIHtcclxuICAgICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcclxuICAgICAgICAgIGFzc2lnbmVkXy5sZW5ndGggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRyYWZ0Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSBkcmFmdF8ubGVuZ3RoOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXNzaWduZWRfW2ldID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IGJhc2VfLmxlbmd0aDsgX2kyIDwgZHJhZnRfLmxlbmd0aDsgX2kyKyspIHtcclxuICAgICAgICAgICAgYXNzaWduZWRfW19pMl0gPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gLy8gTWluaW11bSBjb3VudCBpcyBlbm91Z2gsIHRoZSBvdGhlciBwYXJ0cyBoYXMgYmVlbiBwcm9jZXNzZWQuXHJcblxyXG5cclxuICAgICAgICB2YXIgbWluID0gTWF0aC5taW4oZHJhZnRfLmxlbmd0aCwgYmFzZV8ubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbWluOyBfaTMrKykge1xyXG4gICAgICAgICAgLy8gT25seSB1bnRvdWNoZWQgaW5kaWNlcyB0cmlnZ2VyIHJlY3Vyc2lvbi5cclxuICAgICAgICAgIGlmICghZHJhZnRfLmhhc093blByb3BlcnR5KF9pMykpIHtcclxuICAgICAgICAgICAgYXNzaWduZWRfW19pM10gPSB0cnVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmIChhc3NpZ25lZF9bX2kzXSA9PT0gdW5kZWZpbmVkKSBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0X1tfaTNdKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhhc09iamVjdENoYW5nZXMoc3RhdGUpIHtcclxuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxyXG4gICAgICAgIGRyYWZ0XyA9IHN0YXRlLmRyYWZ0XzsgLy8gU2VhcmNoIGZvciBhZGRlZCBrZXlzIGFuZCBjaGFuZ2VkIGtleXMuIFN0YXJ0IGF0IHRoZSBiYWNrLCBiZWNhdXNlXHJcbiAgICAvLyBub24tbnVtZXJpYyBrZXlzIGFyZSBvcmRlcmVkIGJ5IHRpbWUgb2YgZGVmaW5pdGlvbiBvbiB0aGUgb2JqZWN0LlxyXG5cclxuICAgIHZhciBrZXlzID0gb3duS2V5cyhkcmFmdF8pO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICBpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkgY29udGludWU7XHJcbiAgICAgIHZhciBiYXNlVmFsdWUgPSBiYXNlX1trZXldOyAvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxyXG5cclxuICAgICAgaWYgKGJhc2VWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSAvLyBPbmNlIGEgYmFzZSBrZXkgaXMgZGVsZXRlZCwgZnV0dXJlIGNoYW5nZXMgZ28gdW5kZXRlY3RlZCwgYmVjYXVzZSBpdHNcclxuICAgICAgLy8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAgIHZhciB2YWx1ZSA9IGRyYWZ0X1trZXldO1xyXG5cclxuICAgICAgICAgIHZhciBfc3RhdGUgPSB2YWx1ZSAmJiB2YWx1ZVtEUkFGVF9TVEFURV07XHJcblxyXG4gICAgICAgICAgaWYgKF9zdGF0ZSA/IF9zdGF0ZS5iYXNlXyAhPT0gYmFzZVZhbHVlIDogIWlzKHZhbHVlLCBiYXNlVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbm8ga2V5cyB3ZXJlIGFkZGVkIG9yIGNoYW5nZWQuXHJcbiAgICAvLyBDb21wYXJlIGtleSBjb3VudCB0byBkZXRlcm1pbmUgaWYga2V5cyB3ZXJlIGRlbGV0ZWQuXHJcblxyXG5cclxuICAgIHZhciBiYXNlSXNEcmFmdCA9ICEhYmFzZV9bRFJBRlRfU1RBVEVdO1xyXG4gICAgcmV0dXJuIGtleXMubGVuZ3RoICE9PSBvd25LZXlzKGJhc2VfKS5sZW5ndGggKyAoYmFzZUlzRHJhZnQgPyAwIDogMSk7IC8vICsgMSB0byBjb3JyZWN0IGZvciBEUkFGVF9TVEFURVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSB7XHJcbiAgICB2YXIgZHJhZnRfID0gc3RhdGUuZHJhZnRfO1xyXG4gICAgaWYgKGRyYWZ0Xy5sZW5ndGggIT09IHN0YXRlLmJhc2VfLmxlbmd0aCkgcmV0dXJuIHRydWU7IC8vIFNlZSAjMTE2XHJcbiAgICAvLyBJZiB3ZSBmaXJzdCBzaG9ydGVuIHRoZSBsZW5ndGgsIG91ciBhcnJheSBpbnRlcmNlcHRvcnMgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgLy8gSWYgYWZ0ZXIgdGhhdCBuZXcgaXRlbXMgYXJlIGFkZGVkLCByZXN1bHQgaW4gdGhlIHNhbWUgb3JpZ2luYWwgbGVuZ3RoLFxyXG4gICAgLy8gdGhvc2UgbGFzdCBpdGVtcyB3aWxsIGhhdmUgbm8gaW50ZXJjZXB0aW5nIHByb3BlcnR5LlxyXG4gICAgLy8gU28gaWYgdGhlcmUgaXMgbm8gb3duIGRlc2NyaXB0b3Igb24gdGhlIGxhc3QgcG9zaXRpb24sIHdlIGtub3cgdGhhdCBpdGVtcyB3ZXJlIHJlbW92ZWQgYW5kIGFkZGVkXHJcbiAgICAvLyBOLkIuOiBzcGxpY2UsIHVuc2hpZnQsIGV0YyBvbmx5IHNoaWZ0IHZhbHVlcyBhcm91bmQsIGJ1dCBub3QgcHJvcCBkZXNjcmlwdG9ycywgc28gd2Ugb25seSBoYXZlIHRvIGNoZWNrXHJcbiAgICAvLyB0aGUgbGFzdCBvbmVcclxuICAgIC8vIGxhc3QgZGVzY3JpcHRvciBjYW4gYmUgbm90IGEgdHJhcCwgaWYgdGhlIGFycmF5IHdhcyBleHRlbmRlZFxyXG5cclxuICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkcmFmdF8sIGRyYWZ0Xy5sZW5ndGggLSAxKTsgLy8gZGVzY3JpcHRvciBjYW4gYmUgbnVsbCwgYnV0IG9ubHkgZm9yIG5ld2x5IGNyZWF0ZWQgc3BhcnNlIGFycmF5cywgZWcuIG5ldyBBcnJheSgxMClcclxuXHJcbiAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5nZXQpIHJldHVybiB0cnVlOyAvLyBpZiB3ZSBtaXNzIGEgcHJvcGVydHksIGl0IGhhcyBiZWVuIGRlbGV0ZWQsIHNvIGFycmF5IHByb2JvYmFseSBjaGFuZ2VkXHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFmdF8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKCFkcmFmdF8uaGFzT3duUHJvcGVydHkoaSkpIHJldHVybiB0cnVlO1xyXG4gICAgfSAvLyBGb3IgYWxsIG90aGVyIGNhc2VzLCB3ZSBkb24ndCBoYXZlIHRvIGNvbXBhcmUsIGFzIHRoZXkgd291bGQgaGF2ZSBiZWVuIHBpY2tlZCB1cCBieSB0aGUgaW5kZXggc2V0dGVyc1xyXG5cclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoYXNDaGFuZ2VzXyhzdGF0ZSkge1xyXG4gICAgcmV0dXJuIHN0YXRlLnR5cGVfID09PSA0XHJcbiAgICAvKiBFUzVPYmplY3QgKi9cclxuICAgID8gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZSkgOiBoYXNBcnJheUNoYW5nZXMoc3RhdGUpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlXHJcbiAgLypFUzVTdGF0ZSB8IE1hcFN0YXRlIHwgU2V0U3RhdGUqL1xyXG4gICkge1xyXG4gICAgaWYgKHN0YXRlLnJldm9rZWRfKSBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpO1xyXG4gIH1cclxuXHJcbiAgbG9hZFBsdWdpbihcIkVTNVwiLCB7XHJcbiAgICBjcmVhdGVFUzVQcm94eV86IGNyZWF0ZUVTNVByb3h5XyxcclxuICAgIHdpbGxGaW5hbGl6ZUVTNV86IHdpbGxGaW5hbGl6ZUVTNV8sXHJcbiAgICBoYXNDaGFuZ2VzXzogaGFzQ2hhbmdlc19cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcclxuICB2YXIgUkVQTEFDRSA9IFwicmVwbGFjZVwiO1xyXG4gIHZhciBBREQgPSBcImFkZFwiO1xyXG4gIHZhciBSRU1PVkUgPSBcInJlbW92ZVwiO1xyXG5cclxuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNfKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcclxuICAgIHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcclxuICAgICAgY2FzZSAwXHJcbiAgICAgIC8qIFByb3h5T2JqZWN0ICovXHJcbiAgICAgIDpcclxuICAgICAgY2FzZSA0XHJcbiAgICAgIC8qIEVTNU9iamVjdCAqL1xyXG4gICAgICA6XHJcbiAgICAgIGNhc2UgMlxyXG4gICAgICAvKiBNYXAgKi9cclxuICAgICAgOlxyXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoc3RhdGUsIGJhc2VQYXRoLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlcyk7XHJcblxyXG4gICAgICBjYXNlIDVcclxuICAgICAgLyogRVM1QXJyYXkgKi9cclxuICAgICAgOlxyXG4gICAgICBjYXNlIDFcclxuICAgICAgLyogUHJveHlBcnJheSAqL1xyXG4gICAgICA6XHJcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpO1xyXG5cclxuICAgICAgY2FzZSAzXHJcbiAgICAgIC8qIFNldCAqL1xyXG4gICAgICA6XHJcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcclxuICAgIHZhciBiYXNlXyA9IHN0YXRlLmJhc2VfLFxyXG4gICAgICAgIGFzc2lnbmVkXyA9IHN0YXRlLmFzc2lnbmVkXztcclxuICAgIHZhciBjb3B5XyA9IHN0YXRlLmNvcHlfOyAvLyBSZWR1Y2UgY29tcGxleGl0eSBieSBlbnN1cmluZyBgYmFzZWAgaXMgbmV2ZXIgbG9uZ2VyLlxyXG5cclxuICAgIGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcclxuICAgICAgdmFyIF9yZWYgPSBbY29weV8sIGJhc2VfXTtcclxuICAgICAgYmFzZV8gPSBfcmVmWzBdO1xyXG4gICAgICBjb3B5XyA9IF9yZWZbMV07XHJcbiAgICAgIHZhciBfcmVmMiA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc107XHJcbiAgICAgIHBhdGNoZXMgPSBfcmVmMlswXTtcclxuICAgICAgaW52ZXJzZVBhdGNoZXMgPSBfcmVmMlsxXTtcclxuICAgIH0gLy8gUHJvY2VzcyByZXBsYWNlZCBpbmRpY2VzLlxyXG5cclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChhc3NpZ25lZF9baV0gJiYgY29weV9baV0gIT09IGJhc2VfW2ldKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcclxuICAgICAgICBwYXRjaGVzLnB1c2goe1xyXG4gICAgICAgICAgb3A6IFJFUExBQ0UsXHJcbiAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXHJcbiAgICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChjb3B5X1tpXSlcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcclxuICAgICAgICAgIG9wOiBSRVBMQUNFLFxyXG4gICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlX1tpXSlcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSAvLyBQcm9jZXNzIGFkZGVkIGluZGljZXMuXHJcblxyXG5cclxuICAgIGZvciAodmFyIF9pID0gYmFzZV8ubGVuZ3RoOyBfaSA8IGNvcHlfLmxlbmd0aDsgX2krKykge1xyXG4gICAgICB2YXIgX3BhdGggPSBiYXNlUGF0aC5jb25jYXQoW19pXSk7XHJcblxyXG4gICAgICBwYXRjaGVzLnB1c2goe1xyXG4gICAgICAgIG9wOiBBREQsXHJcbiAgICAgICAgcGF0aDogX3BhdGgsXHJcbiAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXHJcbiAgICAgICAgLy8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW19pXSlcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJhc2VfLmxlbmd0aCA8IGNvcHlfLmxlbmd0aCkge1xyXG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcclxuICAgICAgICBvcDogUkVQTEFDRSxcclxuICAgICAgICBwYXRoOiBiYXNlUGF0aC5jb25jYXQoW1wibGVuZ3RoXCJdKSxcclxuICAgICAgICB2YWx1ZTogYmFzZV8ubGVuZ3RoXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0gLy8gVGhpcyBpcyB1c2VkIGZvciBib3RoIE1hcCBvYmplY3RzIGFuZCBub3JtYWwgb2JqZWN0cy5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XHJcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcclxuICAgICAgICBjb3B5XyA9IHN0YXRlLmNvcHlfO1xyXG4gICAgZWFjaChzdGF0ZS5hc3NpZ25lZF8sIGZ1bmN0aW9uIChrZXksIGFzc2lnbmVkVmFsdWUpIHtcclxuICAgICAgdmFyIG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KTtcclxuICAgICAgdmFyIHZhbHVlID0gZ2V0KGNvcHlfLCBrZXkpO1xyXG4gICAgICB2YXIgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBREQ7XHJcbiAgICAgIGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKSByZXR1cm47XHJcbiAgICAgIHZhciBwYXRoID0gYmFzZVBhdGguY29uY2F0KGtleSk7XHJcbiAgICAgIHBhdGNoZXMucHVzaChvcCA9PT0gUkVNT1ZFID8ge1xyXG4gICAgICAgIG9wOiBvcCxcclxuICAgICAgICBwYXRoOiBwYXRoXHJcbiAgICAgIH0gOiB7XHJcbiAgICAgICAgb3A6IG9wLFxyXG4gICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgIH0pO1xyXG4gICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKG9wID09PSBBREQgPyB7XHJcbiAgICAgICAgb3A6IFJFTU9WRSxcclxuICAgICAgICBwYXRoOiBwYXRoXHJcbiAgICAgIH0gOiBvcCA9PT0gUkVNT1ZFID8ge1xyXG4gICAgICAgIG9wOiBBREQsXHJcbiAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKVxyXG4gICAgICB9IDoge1xyXG4gICAgICAgIG9wOiBSRVBMQUNFLFxyXG4gICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSlcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XHJcbiAgICB2YXIgYmFzZV8gPSBzdGF0ZS5iYXNlXyxcclxuICAgICAgICBjb3B5XyA9IHN0YXRlLmNvcHlfO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgYmFzZV8uZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgaWYgKCFjb3B5Xy5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgdmFyIHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcclxuICAgICAgICBwYXRjaGVzLnB1c2goe1xyXG4gICAgICAgICAgb3A6IFJFTU9WRSxcclxuICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcclxuICAgICAgICAgIG9wOiBBREQsXHJcbiAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGkrKztcclxuICAgIH0pO1xyXG4gICAgaSA9IDA7XHJcbiAgICBjb3B5Xy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICBpZiAoIWJhc2VfLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xyXG4gICAgICAgIHBhdGNoZXMucHVzaCh7XHJcbiAgICAgICAgICBvcDogQURELFxyXG4gICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGludmVyc2VQYXRjaGVzLnVuc2hpZnQoe1xyXG4gICAgICAgICAgb3A6IFJFTU9WRSxcclxuICAgICAgICAgIHBhdGg6IHBhdGgsXHJcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaSsrO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oYmFzZVZhbHVlLCByZXBsYWNlbWVudCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcclxuICAgIHBhdGNoZXMucHVzaCh7XHJcbiAgICAgIG9wOiBSRVBMQUNFLFxyXG4gICAgICBwYXRoOiBbXSxcclxuICAgICAgdmFsdWU6IHJlcGxhY2VtZW50ID09PSBOT1RISU5HID8gdW5kZWZpbmVkIDogcmVwbGFjZW1lbnRcclxuICAgIH0pO1xyXG4gICAgaW52ZXJzZVBhdGNoZXMucHVzaCh7XHJcbiAgICAgIG9wOiBSRVBMQUNFLFxyXG4gICAgICBwYXRoOiBbXSxcclxuICAgICAgdmFsdWU6IGJhc2VWYWx1ZVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXNfKGRyYWZ0LCBwYXRjaGVzKSB7XHJcbiAgICBwYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHBhdGNoKSB7XHJcbiAgICAgIHZhciBwYXRoID0gcGF0Y2gucGF0aCxcclxuICAgICAgICAgIG9wID0gcGF0Y2gub3A7XHJcbiAgICAgIHZhciBiYXNlID0gZHJhZnQ7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudFR5cGUgPSBnZXRBcmNodHlwZShiYXNlKTtcclxuICAgICAgICB2YXIgcCA9IHBhdGhbaV07XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgcCAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcCAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgcCA9IFwiXCIgKyBwO1xyXG4gICAgICAgIH0gLy8gU2VlICM3MzgsIGF2b2lkIHByb3RvdHlwZSBwb2xsdXRpb25cclxuXHJcblxyXG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMFxyXG4gICAgICAgIC8qIE9iamVjdCAqL1xyXG4gICAgICAgIHx8IHBhcmVudFR5cGUgPT09IDFcclxuICAgICAgICAvKiBBcnJheSAqL1xyXG4gICAgICAgICkgJiYgKHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gXCJjb25zdHJ1Y3RvclwiKSkgZGllKDI0KTtcclxuICAgICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiBwID09PSBcInByb3RvdHlwZVwiKSBkaWUoMjQpO1xyXG4gICAgICAgIGJhc2UgPSBnZXQoYmFzZSwgcCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSBkaWUoMTUsIHBhdGguam9pbihcIi9cIikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgdHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xyXG4gICAgICB2YXIgdmFsdWUgPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKHBhdGNoLnZhbHVlKTsgLy8gdXNlZCB0byBjbG9uZSBwYXRjaCB0byBlbnN1cmUgb3JpZ2luYWwgcGF0Y2ggaXMgbm90IG1vZGlmaWVkLCBzZWUgIzQxMVxyXG5cclxuICAgICAgdmFyIGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcclxuXHJcbiAgICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgICBjYXNlIFJFUExBQ0U6XHJcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAyXHJcbiAgICAgICAgICAgIC8qIE1hcCAqL1xyXG4gICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHJcbiAgICAgICAgICAgIGNhc2UgM1xyXG4gICAgICAgICAgICAvKiBTZXQgKi9cclxuICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgIGRpZSgxNik7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIGFuIG9iamVjdCwgdGhlbiBpdCdzIGFzc2lnbmVkIGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgIC8vIGluIHRoZSBmb2xsb3dpbmcgYWRkIG9yIHJlbW92ZSBvcHMsIHRoZSB2YWx1ZSBmaWVsZCBpbnNpZGUgdGhlIHBhdGNoIHdpbGwgYWxzbyBiZSBtb2RpZnllZFxyXG4gICAgICAgICAgICAgIC8vIHNvIHdlIHVzZSB2YWx1ZSBmcm9tIHRoZSBjbG9uZWQgcGF0Y2hcclxuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIEFERDpcclxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDFcclxuICAgICAgICAgICAgLyogQXJyYXkgKi9cclxuICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgIHJldHVybiBrZXkgPT09IFwiLVwiID8gYmFzZS5wdXNoKHZhbHVlKSA6IGJhc2Uuc3BsaWNlKGtleSwgMCwgdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAyXHJcbiAgICAgICAgICAgIC8qIE1hcCAqL1xyXG4gICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAzXHJcbiAgICAgICAgICAgIC8qIFNldCAqL1xyXG4gICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuYWRkKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Vba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICBjYXNlIFJFTU9WRTpcclxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIDFcclxuICAgICAgICAgICAgLyogQXJyYXkgKi9cclxuICAgICAgICAgICAgOlxyXG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNwbGljZShrZXksIDEpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAyXHJcbiAgICAgICAgICAgIC8qIE1hcCAqL1xyXG4gICAgICAgICAgICA6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2UuZGVsZXRlKGtleSk7XHJcblxyXG4gICAgICAgICAgICBjYXNlIDNcclxuICAgICAgICAgICAgLyogU2V0ICovXHJcbiAgICAgICAgICAgIDpcclxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2Vba2V5XTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGRpZSgxNywgb3ApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBkcmFmdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKSB7XHJcbiAgICBpZiAoIWlzRHJhZnRhYmxlKG9iaikpIHJldHVybiBvYmo7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKTtcclxuICAgIGlmIChpc01hcChvYmopKSByZXR1cm4gbmV3IE1hcChBcnJheS5mcm9tKG9iai5lbnRyaWVzKCkpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcclxuICAgICAgdmFyIGsgPSBfcmVmM1swXSxcclxuICAgICAgICAgIHYgPSBfcmVmM1sxXTtcclxuICAgICAgcmV0dXJuIFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXTtcclxuICAgIH0pKTtcclxuICAgIGlmIChpc1NldChvYmopKSByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKTtcclxuICAgIHZhciBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcclxuXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGhhcyhvYmosIERSQUZUQUJMRSkpIGNsb25lZFtEUkFGVEFCTEVdID0gb2JqW0RSQUZUQUJMRV07XHJcbiAgICByZXR1cm4gY2xvbmVkO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob2JqKSB7XHJcbiAgICBpZiAoaXNEcmFmdChvYmopKSB7XHJcbiAgICAgIHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaik7XHJcbiAgICB9IGVsc2UgcmV0dXJuIG9iajtcclxuICB9XHJcblxyXG4gIGxvYWRQbHVnaW4oXCJQYXRjaGVzXCIsIHtcclxuICAgIGFwcGx5UGF0Y2hlc186IGFwcGx5UGF0Y2hlc18sXHJcbiAgICBnZW5lcmF0ZVBhdGNoZXNfOiBnZW5lcmF0ZVBhdGNoZXNfLFxyXG4gICAgZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfOiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cclxuICB9KTtcclxufVxyXG5cclxuLy8gdHlwZXMgb25seSFcclxuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgdmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XHJcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XHJcbiAgICAgIF9fcHJvdG9fXzogW11cclxuICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XHJcbiAgICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgIGZvciAodmFyIHAgaW4gYikge1xyXG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gX2V4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgfTsgLy8gVWdseSBoYWNrIHRvIHJlc29sdmUgIzUwMiBhbmQgaW5oZXJpdCBidWlsdCBpbiBNYXAgLyBTZXRcclxuXHJcblxyXG4gIGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBfXygpIHtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XHJcbiAgICB9XHJcblxyXG4gICAgZC5wcm90b3R5cGUgPSAoIC8vIEB0cy1pZ25vcmVcclxuICAgIF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgfVxyXG5cclxuICB2YXIgRHJhZnRNYXAgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRHJhZnRNYXAsIF9zdXBlcik7IC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudCkge1xyXG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcclxuICAgICAgICB0eXBlXzogMlxyXG4gICAgICAgIC8qIE1hcCAqL1xyXG4gICAgICAgICxcclxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXHJcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXHJcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcclxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcclxuICAgICAgICBjb3B5XzogdW5kZWZpbmVkLFxyXG4gICAgICAgIGFzc2lnbmVkXzogdW5kZWZpbmVkLFxyXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXHJcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxyXG4gICAgICAgIGlzTWFudWFsXzogZmFsc2UsXHJcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwID0gRHJhZnRNYXAucHJvdG90eXBlO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwic2l6ZVwiLCB7XHJcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XHJcbiAgICAgIH0gLy8gZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgIC8vIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG5cclxuICAgIH0pO1xyXG5cclxuICAgIHAuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5oYXMoa2V5KTtcclxuICAgIH07XHJcblxyXG4gICAgcC5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuXHJcbiAgICAgIGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xyXG4gICAgICAgIHByZXBhcmVNYXBDb3B5KHN0YXRlKTtcclxuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XHJcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfLnNldChrZXksIHRydWUpO1xyXG4gICAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIHZhbHVlKTtcclxuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xyXG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XHJcblxyXG4gICAgICBpZiAoc3RhdGUuYmFzZV8uaGFzKGtleSkpIHtcclxuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5kZWxldGUoa2V5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RhdGUuY29weV8uZGVsZXRlKGtleSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuXHJcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcclxuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XHJcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBlYWNoKHN0YXRlLmJhc2VfLCBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcC5mb3JFYWNoID0gZnVuY3Rpb24gKGNiLCB0aGlzQXJnKSB7XHJcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgbGF0ZXN0KHN0YXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChfdmFsdWUsIGtleSwgX21hcCkge1xyXG4gICAgICAgIGNiLmNhbGwodGhpc0FyZywgX3RoaXMuZ2V0KGtleSksIGtleSwgX3RoaXMpO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcC5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xyXG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xyXG4gICAgICB2YXIgdmFsdWUgPSBsYXRlc3Qoc3RhdGUpLmdldChrZXkpO1xyXG5cclxuICAgICAgaWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHZhbHVlICE9PSBzdGF0ZS5iYXNlXy5nZXQoa2V5KSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTsgLy8gZWl0aGVyIGFscmVhZHkgZHJhZnRlZCBvciByZWFzc2lnbmVkXHJcbiAgICAgIH0gLy8gZGVzcGl0ZSB3aGF0IGl0IGxvb2tzLCB0aGlzIGNyZWF0ZXMgYSBkcmFmdCBvbmx5IG9uY2UsIHNlZSBhYm92ZSBjb25kaXRpb25cclxuXHJcblxyXG4gICAgICB2YXIgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpO1xyXG4gICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XHJcbiAgICAgIHN0YXRlLmNvcHlfLnNldChrZXksIGRyYWZ0KTtcclxuICAgICAgcmV0dXJuIGRyYWZ0O1xyXG4gICAgfTtcclxuXHJcbiAgICBwLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcC52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzLFxyXG4gICAgICAgICAgX3JlZjtcclxuXHJcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xyXG4gICAgICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMyLnZhbHVlcygpO1xyXG4gICAgICB9LCBfcmVmLm5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgIHZhciByID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblxyXG4gICAgICAgIGlmIChyLmRvbmUpIHJldHVybiByO1xyXG5cclxuICAgICAgICB2YXIgdmFsdWUgPSBfdGhpczIuZ2V0KHIudmFsdWUpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgICB9LCBfcmVmO1xyXG4gICAgfTtcclxuXHJcbiAgICBwLmVudHJpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzLFxyXG4gICAgICAgICAgX3JlZjI7XHJcblxyXG4gICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmtleXMoKTtcclxuICAgICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX3RoaXMzLmVudHJpZXMoKTtcclxuICAgICAgfSwgX3JlZjIubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICAgICAgdmFyIHIgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHJcbiAgICAgICAgaWYgKHIuZG9uZSkgcmV0dXJuIHI7XHJcblxyXG4gICAgICAgIHZhciB2YWx1ZSA9IF90aGlzMy5nZXQoci52YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgIHZhbHVlOiBbci52YWx1ZSwgdmFsdWVdXHJcbiAgICAgICAgfTtcclxuICAgICAgfSwgX3JlZjI7XHJcbiAgICB9O1xyXG5cclxuICAgIHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBEcmFmdE1hcDtcclxuICB9KE1hcCk7XHJcblxyXG4gIGZ1bmN0aW9uIHByb3h5TWFwXyh0YXJnZXQsIHBhcmVudCkge1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcmV0dXJuIG5ldyBEcmFmdE1hcCh0YXJnZXQsIHBhcmVudCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcmVwYXJlTWFwQ29weShzdGF0ZSkge1xyXG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xyXG4gICAgICBzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKCk7XHJcbiAgICAgIHN0YXRlLmNvcHlfID0gbmV3IE1hcChzdGF0ZS5iYXNlXyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgRHJhZnRTZXQgPSBmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRHJhZnRTZXQsIF9zdXBlcik7IC8vIENyZWF0ZSBjbGFzcyBtYW51YWxseSwgY2F1c2UgIzUwMlxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCkge1xyXG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcclxuICAgICAgICB0eXBlXzogM1xyXG4gICAgICAgIC8qIFNldCAqL1xyXG4gICAgICAgICxcclxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXHJcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXHJcbiAgICAgICAgbW9kaWZpZWRfOiBmYWxzZSxcclxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcclxuICAgICAgICBjb3B5XzogdW5kZWZpbmVkLFxyXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXHJcbiAgICAgICAgZHJhZnRfOiB0aGlzLFxyXG4gICAgICAgIGRyYWZ0c186IG5ldyBNYXAoKSxcclxuICAgICAgICByZXZva2VkXzogZmFsc2UsXHJcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcCA9IERyYWZ0U2V0LnByb3RvdHlwZTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xyXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xyXG4gICAgICB9IC8vIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgcC5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XHJcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7IC8vIGJpdCBvZiB0cmlja2VyeSBoZXJlLCB0byBiZSBhYmxlIHRvIHJlY29nbml6ZSBib3RoIHRoZSB2YWx1ZSwgYW5kIHRoZSBkcmFmdCBvZiBpdHMgdmFsdWVcclxuXHJcbiAgICAgIGlmICghc3RhdGUuY29weV8pIHtcclxuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHN0YXRlLmNvcHlfLmhhcyh2YWx1ZSkpIHJldHVybiB0cnVlO1xyXG4gICAgICBpZiAoc3RhdGUuZHJhZnRzXy5oYXModmFsdWUpICYmIHN0YXRlLmNvcHlfLmhhcyhzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwLmFkZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuXHJcbiAgICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB7XHJcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xyXG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcclxuICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgcC5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xyXG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xyXG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XHJcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcclxuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmRlbGV0ZSh2YWx1ZSkgfHwgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSA/IHN0YXRlLmNvcHlfLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpIDpcclxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcclxuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcclxuXHJcbiAgICAgIGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcclxuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XHJcbiAgICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xyXG4gICAgICAgIHN0YXRlLmNvcHlfLmNsZWFyKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcC52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xyXG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xyXG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XHJcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy52YWx1ZXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcC5lbnRyaWVzID0gZnVuY3Rpb24gZW50cmllcygpIHtcclxuICAgICAgdmFyIHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XHJcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XHJcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcclxuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfLmVudHJpZXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcC5rZXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XHJcbiAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XHJcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XHJcblxyXG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcyk7XHJcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBEcmFmdFNldDtcclxuICB9KFNldCk7XHJcblxyXG4gIGZ1bmN0aW9uIHByb3h5U2V0Xyh0YXJnZXQsIHBhcmVudCkge1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcmV0dXJuIG5ldyBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcmVwYXJlU2V0Q29weShzdGF0ZSkge1xyXG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xyXG4gICAgICAvLyBjcmVhdGUgZHJhZnRzIGZvciBhbGwgZW50cmllcyB0byBwcmVzZXJ2ZSBpbnNlcnRpb24gb3JkZXJcclxuICAgICAgc3RhdGUuY29weV8gPSBuZXcgU2V0KCk7XHJcbiAgICAgIHN0YXRlLmJhc2VfLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGlzRHJhZnRhYmxlKHZhbHVlKSkge1xyXG4gICAgICAgICAgdmFyIGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLmltbWVyXywgdmFsdWUsIHN0YXRlKTtcclxuICAgICAgICAgIHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdCk7XHJcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQoZHJhZnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGVcclxuICAvKkVTNVN0YXRlIHwgTWFwU3RhdGUgfCBTZXRTdGF0ZSovXHJcbiAgKSB7XHJcbiAgICBpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSk7XHJcbiAgfVxyXG5cclxuICBsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHtcclxuICAgIHByb3h5TWFwXzogcHJveHlNYXBfLFxyXG4gICAgcHJveHlTZXRfOiBwcm94eVNldF9cclxuICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5hYmxlQWxsUGx1Z2lucygpIHtcclxuICBlbmFibGVFUzUoKTtcclxuICBlbmFibGVNYXBTZXQoKTtcclxuICBlbmFibGVQYXRjaGVzKCk7XHJcbn1cclxuXHJcbnZhciBpbW1lciA9XHJcbi8qI19fUFVSRV9fKi9cclxubmV3IEltbWVyKCk7XHJcbi8qKlxyXG4gKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcclxuICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXHJcbiAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxyXG4gKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxyXG4gKlxyXG4gKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcclxuICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cclxuICpcclxuICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXHJcbiAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cclxuICpcclxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxyXG4gKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcclxuICovXHJcblxyXG52YXIgcHJvZHVjZSA9IGltbWVyLnByb2R1Y2U7XHJcbi8qKlxyXG4gKiBMaWtlIGBwcm9kdWNlYCwgYnV0IGBwcm9kdWNlV2l0aFBhdGNoZXNgIGFsd2F5cyByZXR1cm5zIGEgdHVwbGVcclxuICogW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdIChpbnN0ZWFkIG9mIGp1c3QgdGhlIG5leHQgc3RhdGUpXHJcbiAqL1xyXG5cclxudmFyIHByb2R1Y2VXaXRoUGF0Y2hlcyA9XHJcbi8qI19fUFVSRV9fKi9cclxuaW1tZXIucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQoaW1tZXIpO1xyXG4vKipcclxuICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cclxuICpcclxuICogQWx3YXlzIGZyZWV6ZSBieSBkZWZhdWx0LCBldmVuIGluIHByb2R1Y3Rpb24gbW9kZVxyXG4gKi9cclxuXHJcbnZhciBzZXRBdXRvRnJlZXplID1cclxuLyojX19QVVJFX18qL1xyXG5pbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpO1xyXG4vKipcclxuICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXHJcbiAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cclxuICpcclxuICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXHJcbiAqL1xyXG5cclxudmFyIHNldFVzZVByb3hpZXMgPVxyXG4vKiNfX1BVUkVfXyovXHJcbmltbWVyLnNldFVzZVByb3hpZXMuYmluZChpbW1lcik7XHJcbi8qKlxyXG4gKiBBcHBseSBhbiBhcnJheSBvZiBJbW1lciBwYXRjaGVzIHRvIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICpcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHByb2R1Y2VyLCB3aGljaCBtZWFucyBjb3B5LW9uLXdyaXRlIGlzIGluIGVmZmVjdC5cclxuICovXHJcblxyXG52YXIgYXBwbHlQYXRjaGVzID1cclxuLyojX19QVVJFX18qL1xyXG5pbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcik7XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gSW1tZXIgZHJhZnQgZnJvbSB0aGUgZ2l2ZW4gYmFzZSBzdGF0ZSwgd2hpY2ggbWF5IGJlIGEgZHJhZnQgaXRzZWxmLlxyXG4gKiBUaGUgZHJhZnQgY2FuIGJlIG1vZGlmaWVkIHVudGlsIHlvdSBmaW5hbGl6ZSBpdCB3aXRoIHRoZSBgZmluaXNoRHJhZnRgIGZ1bmN0aW9uLlxyXG4gKi9cclxuXHJcbnZhciBjcmVhdGVEcmFmdCA9XHJcbi8qI19fUFVSRV9fKi9cclxuaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcik7XHJcbi8qKlxyXG4gKiBGaW5hbGl6ZSBhbiBJbW1lciBkcmFmdCBmcm9tIGEgYGNyZWF0ZURyYWZ0YCBjYWxsLCByZXR1cm5pbmcgdGhlIGJhc2Ugc3RhdGVcclxuICogKGlmIG5vIGNoYW5nZXMgd2VyZSBtYWRlKSBvciBhIG1vZGlmaWVkIGNvcHkuIFRoZSBkcmFmdCBtdXN0ICpub3QqIGJlXHJcbiAqIG11dGF0ZWQgYWZ0ZXJ3YXJkcy5cclxuICpcclxuICogUGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSAybmQgYXJndW1lbnQgdG8gZ2VuZXJhdGUgSW1tZXIgcGF0Y2hlcyBiYXNlZCBvbiB0aGVcclxuICogY2hhbmdlcyB0aGF0IHdlcmUgbWFkZS5cclxuICovXHJcblxyXG52YXIgZmluaXNoRHJhZnQgPVxyXG4vKiNfX1BVUkVfXyovXHJcbmltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpO1xyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxyXG4gKiB0byBhbiBkcmFmdCB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICpcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY2FzdERyYWZ0KHZhbHVlKSB7XHJcbiAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgbm8tb3AsIGJ1dCBjYW4gYmUgdXNlZCB0byBjYXN0IGEgbXV0YWJsZSB0eXBlXHJcbiAqIHRvIGFuIGltbXV0YWJsZSB0eXBlIGFuZCBtYWtlIFR5cGVTY3JpcHQgaGFwcHlcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gY2FzdEltbXV0YWJsZSh2YWx1ZSkge1xyXG4gIHJldHVybiB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0cy5JbW1lciA9IEltbWVyO1xyXG5leHBvcnRzLmFwcGx5UGF0Y2hlcyA9IGFwcGx5UGF0Y2hlcztcclxuZXhwb3J0cy5jYXN0RHJhZnQgPSBjYXN0RHJhZnQ7XHJcbmV4cG9ydHMuY2FzdEltbXV0YWJsZSA9IGNhc3RJbW11dGFibGU7XHJcbmV4cG9ydHMuY3JlYXRlRHJhZnQgPSBjcmVhdGVEcmFmdDtcclxuZXhwb3J0cy5jdXJyZW50ID0gY3VycmVudDtcclxuZXhwb3J0cy5kZWZhdWx0ID0gcHJvZHVjZTtcclxuZXhwb3J0cy5lbmFibGVBbGxQbHVnaW5zID0gZW5hYmxlQWxsUGx1Z2lucztcclxuZXhwb3J0cy5lbmFibGVFUzUgPSBlbmFibGVFUzU7XHJcbmV4cG9ydHMuZW5hYmxlTWFwU2V0ID0gZW5hYmxlTWFwU2V0O1xyXG5leHBvcnRzLmVuYWJsZVBhdGNoZXMgPSBlbmFibGVQYXRjaGVzO1xyXG5leHBvcnRzLmZpbmlzaERyYWZ0ID0gZmluaXNoRHJhZnQ7XHJcbmV4cG9ydHMuZnJlZXplID0gZnJlZXplO1xyXG5leHBvcnRzLmltbWVyYWJsZSA9IERSQUZUQUJMRTtcclxuZXhwb3J0cy5pc0RyYWZ0ID0gaXNEcmFmdDtcclxuZXhwb3J0cy5pc0RyYWZ0YWJsZSA9IGlzRHJhZnRhYmxlO1xyXG5leHBvcnRzLm5vdGhpbmcgPSBOT1RISU5HO1xyXG5leHBvcnRzLm9yaWdpbmFsID0gb3JpZ2luYWw7XHJcbmV4cG9ydHMucHJvZHVjZSA9IHByb2R1Y2U7XHJcbmV4cG9ydHMucHJvZHVjZVdpdGhQYXRjaGVzID0gcHJvZHVjZVdpdGhQYXRjaGVzO1xyXG5leHBvcnRzLnNldEF1dG9GcmVlemUgPSBzZXRBdXRvRnJlZXplO1xyXG5leHBvcnRzLnNldFVzZVByb3hpZXMgPSBzZXRVc2VQcm94aWVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5janMuZGV2ZWxvcG1lbnQuanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/immer.cjs.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/immer/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/immer/dist/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\r\n\r\n\r\nif (false) {} else {\r\n  module.exports = __webpack_require__(/*! ./immer.cjs.development.js */ \"(ssr)/./node_modules/immer/dist/immer.cjs.development.js\")\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNZO0FBQ1o7QUFDQSxJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsa0lBQXNEO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnQtZW5kLy4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW5kZXguanM/MDhmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuJ3VzZSBzdHJpY3QnXHJcblxyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbW1lci5janMucHJvZHVjdGlvbi5taW4uanMnKVxyXG59IGVsc2Uge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9pbW1lci5janMuZGV2ZWxvcG1lbnQuanMnKVxyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/immer/dist/index.js\n");

/***/ })

};
;